          text: "æ‰¿çŸ¥ã—ã¾ã—ãŸã€‚å¼•ãç¶šããƒ†ã‚­ã‚¹ãƒˆã§ã®å›ç­”ã‚’è¡Œã„ã¾ã™ã€‚"
        });
      }
      // ã©ã¡ã‚‰ã§ã‚‚ãªã„å ´åˆã¯é€šå¸¸ã®å‡¦ç†ã‚’ç¶šè¡Œ
    }
    
    // ç‰¹æ€§åˆ†æã«é–¢é€£ã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‹ã©ã†ã‹ã‚’æ¤œå‡º
    if (userMessage && (
      userMessage.includes('ç‰¹æ€§') || 
      userMessage.includes('åˆ†æ') || 
      userMessage.includes('æ€§æ ¼') || 
      userMessage.includes('éå»ã®è¨˜éŒ²') || 
      userMessage.includes('å±¥æ­´')
    )) {
      console.log(`\n======= ç‰¹æ€§åˆ†æãƒªã‚¯ã‚¨ã‚¹ãƒˆæ¤œå‡º =======`);
      console.log(`â†’ ãƒ¦ãƒ¼ã‚¶ãƒ¼ID: ${userId}`);
      console.log(`â†’ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: ${userMessage}`);
      console.log(`======= ç‰¹æ€§åˆ†æãƒªã‚¯ã‚¨ã‚¹ãƒˆæ¤œå‡ºçµ‚äº† =======\n`);
    }
    
    // Define feedback patterns for sentiment detection
    const FEEDBACK_PATTERNS = {
      positive: ['ã‚ã‚ŠãŒã¨ã†', 'thank', 'thanks', 'good', 'helpful', 'useful', 'great', 'excellent', 'åŠ©ã‹ã‚‹', 'å½¹ã«ç«‹ã¤', 'ã„ã„ã­', 'ã™ã”ã„', 'ç´ æ™´ã‚‰ã—ã„'],
      negative: ['é•ã†', 'wrong', 'bad', 'not helpful', 'useless', 'poor', 'terrible', 'å½¹ã«ç«‹ãŸãªã„', 'é•ã„ã¾ã™', 'ã ã‚', 'ãƒ€ãƒ¡', 'é•ã„ã¾ã™ã‚ˆ', 'é•ã†ã‚ˆ']
    };
    
    // Check for general help request
    if (userMessage.toLowerCase() === 'ãƒ˜ãƒ«ãƒ—' || 
        userMessage.toLowerCase() === 'help' || 
        userMessage.toLowerCase() === 'ã¸ã‚‹ã·') {
      // Return the general help message
      await client.replyMessage(event.replyToken, {
        type: 'text',
        text: helpSystem.getGeneralHelp()
      });
      return;
    }
    
    // Get user preferences to check for recently shown services
    const preferences = userPreferences.getUserPreferences(userId);
    
    // Check if this is a share mode message
    const { mode, limit } = determineModeAndLimit(userMessage);
    
    // ã‚·ã‚§ã‚¢ãƒ¢ãƒ¼ãƒ‰ãŒåˆ¤å®šã•ã‚ŒãŸå ´åˆã®LLMç¢ºèªå‡¦ç†
    if (mode === 'share') {
      console.log(`Share mode triggered by determineModeAndLimit, confirming with LLM...`);
      const history = await fetchUserHistory(userId, 10);
      const isHighEngagement = await checkHighEngagement(userMessage, history);
      
      if (isHighEngagement) {
        console.log(`High engagement confirmed by LLM, sending sharing URL to user ${userId}`);
        // Send sharing message with Twitter URL
        await storeInteraction(userId, 'user', userMessage);
        const shareMessage = `ãŠè¤’ã‚ã®è¨€è‘‰ã‚’ã„ãŸã ãã€ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ï¼ğŸ˜Š

Adamã‚’ãŠå½¹ç«‹ã¦ã„ãŸã ã‘ã¦ã„ã‚‹ã‚ˆã†ã§ã€é–‹ç™ºãƒãƒ¼ãƒ ä¸€åŒã¨ã¦ã‚‚å¬‰ã—ãæ€ã„ã¾ã™ã€‚ã‚‚ã—ã‚ˆã‚ã—ã‘ã‚Œã°ã€ä¸‹è¨˜ã®ãƒªãƒ³ã‚¯ã‹ã‚‰X(Twitter)ã§ã‚·ã‚§ã‚¢ã—ã¦ã„ãŸã ã‘ã‚‹ã¨ã€ã‚ˆã‚Šå¤šãã®æ–¹ã«AIã‚«ã‚¦ãƒ³ã‚»ãƒ©ãƒ¼ã€ŒAdamã€ã‚’çŸ¥ã£ã¦ã„ãŸã ã‘ã¾ã™ã€‚

${SHARE_URL}

é€šå¸¸ã®ä¼šè©±ã«æˆ»ã‚‹å ´åˆã¯ã€ãã®ã¾ã¾è³ªå•ã‚„ç›¸è«‡ã‚’ç¶šã‘ã¦ã„ãŸã ã‘ã‚Œã°ã¨æ€ã„ã¾ã™ã€‚`;

        await client.replyMessage(event.replyToken, {
          type: 'text',
          text: shareMessage
        });
        await storeInteraction(userId, 'assistant', shareMessage);
        return;
      } else {
        console.log(`LLM did not confirm high engagement despite keywords, processing as normal message`);
      }
    }
    
    // Track implicit feedback for recently shown services (continue with original handleText implementation)
    if (preferences && preferences.recentlyShownServices) {
      // Get services shown in the last hour
      const oneHourAgo = Date.now() - 3600000;
      let recentServices = [];
      
      // Collect service IDs shown in the last hour
      Object.entries(preferences.recentlyShownServices).forEach(([timestamp, services]) => {
        if (parseInt(timestamp) > oneHourAgo) {
          recentServices = [...recentServices, ...services];
        }
      });
      
      // If there are recent services, track implicit feedback
      if (recentServices.length > 0) {
        console.log(`Tracking implicit feedback for ${recentServices.length} recently shown services`);
        const feedbackResult = userPreferences.trackImplicitFeedback(userId, userMessage, recentServices);
        
        // If positive feedback was detected and preferences were updated, respond accordingly
        if (feedbackResult === true) {
          // Respond with a friendly acknowledgement
          return client.replyMessage(event.replyToken, {
            type: 'text',
            text: 'ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ï¼ä»Šå¾Œã‚‚å½¹ç«‹ã¤ã‚µãƒ¼ãƒ“ã‚¹ã‚’ã”ç´¹ä»‹ã—ã¾ã™ã€‚'
          });
        }
        
        // Clean up old entries
        const newRecentlyShownServices = {};
        Object.entries(preferences.recentlyShownServices).forEach(([timestamp, services]) => {
          if (parseInt(timestamp) > oneHourAgo) {
            newRecentlyShownServices[timestamp] = services;
          }
        });
        preferences.recentlyShownServices = newRecentlyShownServices;
        userPreferences.updateUserPreferences(userId, preferences);
      }
    }

    // Check for user preference commands
    const updatedPreferences = userPreferences.processPreferenceCommand(userId, userMessage);
    if (updatedPreferences) {
      let responseMessage = '';
      
      // Handle help request
      if (updatedPreferences.helpRequested) {
        responseMessage = userPreferences.getHelpMessage();
      } 
      // Handle settings check request
      else if (updatedPreferences.settingsRequested) {
        responseMessage = userPreferences.getCurrentSettingsMessage(userId);
      }
      // Handle preference updates
      else {
        // Create a more conversational response based on what was changed
        if (updatedPreferences.showServiceRecommendations !== undefined) {
          if (updatedPreferences.showServiceRecommendations) {
            // Check if this was triggered by positive feedback
            const lowerMessage = userMessage.toLowerCase();
            const isPositiveFeedback = FEEDBACK_PATTERNS.positive.some(pattern => lowerMessage.includes(pattern)) && 
                                      !FEEDBACK_PATTERNS.negative.some(pattern => lowerMessage.includes(pattern));
            
            if (isPositiveFeedback) {
              // Friendly response for positive feedback
              responseMessage = `ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ï¼ä»Šå¾Œã‚‚å½¹ç«‹ã¤ã‚µãƒ¼ãƒ“ã‚¹ã‚’ã”ç´¹ä»‹ã—ã¾ã™ã€‚`;
            } else {
              responseMessage = `ã‚µãƒ¼ãƒ“ã‚¹è¡¨ç¤ºã‚’ã‚ªãƒ³ã«ã—ã¾ã—ãŸã€‚ãŠå½¹ç«‹ã¡ãã†ãªã‚µãƒ¼ãƒ“ã‚¹ãŒã‚ã‚Œã°ã€ä¼šè©±ã®ä¸­ã§ã”ç´¹ä»‹ã—ã¾ã™ã€‚`;
            }
          } else {
            // Check if this was triggered by negative feedback
            const lowerMessage = userMessage.toLowerCase();
            const isNegativeFeedback = FEEDBACK_PATTERNS.negative.some(pattern => lowerMessage.includes(pattern));
            
            if (isNegativeFeedback) {
              // Minimal response for negative feedback
              responseMessage = `ã‚ã‹ã‚Šã¾ã—ãŸã€‚`;
            } else {
              responseMessage = `ã‚µãƒ¼ãƒ“ã‚¹è¡¨ç¤ºã‚’ã‚ªãƒ•ã«ã—ã¾ã—ãŸã€‚`;
            }
          }
        } else if (updatedPreferences.maxRecommendations !== undefined) {
          if (updatedPreferences.maxRecommendations === 0) {
            responseMessage = `ã‚µãƒ¼ãƒ“ã‚¹ã‚’è¡¨ç¤ºã—ãªã„è¨­å®šã«ã—ã¾ã—ãŸã€‚`;
          } else {
            responseMessage = `è¡¨ç¤ºã™ã‚‹ã‚µãƒ¼ãƒ“ã‚¹ã®æ•°ã‚’${updatedPreferences.maxRecommendations}ä»¶ã«è¨­å®šã—ã¾ã—ãŸã€‚`;
          }
        } else if (updatedPreferences.minConfidenceScore !== undefined) {
          responseMessage = `ä¿¡é ¼åº¦${Math.round(updatedPreferences.minConfidenceScore * 100)}%ä»¥ä¸Šã®ã‚µãƒ¼ãƒ“ã‚¹ã®ã¿è¡¨ç¤ºã™ã‚‹ã‚ˆã†ã«è¨­å®šã—ã¾ã—ãŸã€‚`;
        } else {
          // Fallback to current settings if we can't determine what changed
          responseMessage = userPreferences.getCurrentSettingsMessage(userId);
        }
      }
      
      await client.replyMessage(event.replyToken, {
        type: 'text',
        text: responseMessage
      });
      
      // Store the interaction
      await storeInteraction(userId, 'user', userMessage);
      await storeInteraction(userId, 'assistant', responseMessage);
      
      return;
    }
    
    // ç‰¹å®šã®å•ã„åˆã‚ã›ï¼ˆASDæ”¯æ´ã®è³ªå•ä¾‹ã‚„ä½¿ã„æ–¹ã®æ¡ˆå†…ï¼‰ã‚’æ¤œå‡º
    if (userMessage.includes("ASDç—‡æ”¯æ´ã§ã‚ãªãŸãŒå¯¾å¿œã§ãã‚‹å…·ä½“çš„ãªè³ªå•ä¾‹") && userMessage.includes("ä½¿ã„æ–¹")) {
      // Check if this user recently received an image generation - if so, skip ASD guide
      const recentImageTimestamp = recentImageGenerationUsers.get(userId);
      console.log(`[DEBUG] ASD Guide check - User ${userId} has recentImageTimestamp: ${recentImageTimestamp ? 'YES' : 'NO'}`);
      if (recentImageTimestamp) {
        const timeSinceImage = Date.now() - recentImageTimestamp;
        console.log(`[DEBUG] ASD Guide check - Time since image generation: ${timeSinceImage}ms, Protection threshold: 30000ms`);
      }
      
      if (recentImageTimestamp && (Date.now() - recentImageTimestamp < 30000)) { // 30 seconds protection
        console.log(`User ${userId} recently received image generation, skipping ASD guide`);
        recentImageGenerationUsers.delete(userId); // Clean up after use
        return;
      }
      
      return handleASDUsageInquiry(event);
    }
    
    // Check if image generation is in progress for this user - if so, skip further processing
    if (imageGenerationInProgress.has(userId)) {
      console.log(`Image generation in progress for ${userId}, skipping additional message handling`);
      return;
    }
    
    // pendingImageExplanations ã®ãƒã‚§ãƒƒã‚¯ï¼ˆã¯ã„/ã„ã„ãˆ åˆ¤å®šï¼‰ã¯å†’é ­ã§å®Ÿæ–½æ¸ˆã¿
    // ä»¥ä¸‹ã®é‡è¤‡ã™ã‚‹ã‚³ãƒ¼ãƒ‰ã‚’å‰Šé™¤
    /*
    if (pendingImageExplanations.has(userId)) {
      const pendingData = pendingImageExplanations.get(userId);
      const now = Date.now();
      if (pendingData.timestamp && (now - pendingData.timestamp > 5 * 60 * 1000)) { // 5åˆ†ã§ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
        console.log(`[DEBUG-IMAGE] Pending image request expired for ${userId} - ${Math.round((now - pendingData.timestamp)/1000)}s elapsed (max: 300s)`);
        pendingImageExplanations.delete(userId);
        // é€šå¸¸ã®å‡¦ç†ã‚’ç¶šè¡Œ
      } else if (userMessage === "ã¯ã„") {
        console.log(`[DEBUG-IMAGE] 'ã¯ã„' detected for user ${userId}, proceeding with image generation`);
        console.log(`[DEBUG-IMAGE] pendingData details: timestamp=${new Date(pendingData.timestamp).toISOString()}, contentLength=${pendingData.content ? pendingData.content.length : 0}`);
        
        // contentãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
        if (!pendingData.content) {
          console.log(`[DEBUG-IMAGE] Error: pendingData.content is ${pendingData.content}`);
          await client.replyMessage(event.replyToken, {
            type: 'text',
            text: "ç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ã€‚ç”»åƒç”Ÿæˆã«å¿…è¦ãªæƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚"
          });
          pendingImageExplanations.delete(userId);
          return;
        }
        
        const explanationText = pendingData.content;
        pendingImageExplanations.delete(userId);
        console.log(`[DEBUG-IMAGE] ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã€Œã¯ã„ã€ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸã€‚ç”»åƒç”Ÿæˆã‚’é–‹å§‹ã—ã¾ã™ã€‚å†…å®¹: "${explanationText.substring(0, 30)}..."`);
        return handleVisionExplanation(event, explanationText);
      } else if (userMessage === "ã„ã„ãˆ") {
        console.log(`[DEBUG-IMAGE] 'ã„ã„ãˆ' detected for user ${userId}, cancelling image generation`);
        pendingImageExplanations.delete(userId);
        console.log(`[DEBUG-IMAGE] ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã€Œã„ã„ãˆã€ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸã€‚ç”»åƒç”Ÿæˆã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã™ã€‚`);
        return client.replyMessage(event.replyToken, {
          type: 'text',
          text: "æ‰¿çŸ¥ã—ã¾ã—ãŸã€‚å¼•ãç¶šããƒ†ã‚­ã‚¹ãƒˆã§ã®å›ç­”ã‚’è¡Œã„ã¾ã™ã€‚"
        });
      }
    }
    */

    // Add prevention check for users who just received image generation (prevents ASD guide sending)
    const recentImageTimestamp = recentImageGenerationUsers.get(userId);
    if (recentImageTimestamp) {
      const timeSinceImage = Date.now() - recentImageTimestamp;
      console.log(`[DEBUG] Recent image check - User ${userId}, time since image: ${timeSinceImage}ms, threshold: 10000ms`);
    }

    if (recentImageTimestamp && (Date.now() - recentImageTimestamp < 10000)) {
      console.log("ç”»åƒç”Ÿæˆç›´å¾Œã®ãŸã‚ã€é‡è¤‡å¿œç­”ã‚’é˜²æ­¢ã—ã¾ã™ã€‚");
      recentImageGenerationUsers.delete(userId);
      return;
    }

    // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯
    const isSafe = await securityFilterPrompt(userMessage);
    if (!isSafe) {
      const refusal = 'ç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«ã¯å¯¾å¿œã§ãã¾ã›ã‚“ã€‚';
      await storeInteraction(userId, 'assistant', refusal);
      await client.replyMessage(event.replyToken, { type: 'text', text: refusal });
      return null;
    }

    // æœ€è¿‘ã®ä¼šè©±å±¥æ­´ã®å–å¾—
    const historyData = await fetchUserHistory(userId, 10);
    const historyForProcessing = historyData.history || [];
    const historyMetadata = historyData.metadata || {};
    const systemPrompt = getSystemPromptForMode(mode);

    // ç”»åƒèª¬æ˜ã®ææ¡ˆãƒˆãƒªã‚¬ãƒ¼ãƒã‚§ãƒƒã‚¯ï¼šisConfusionRequest ã®ã¿ã‚’ä½¿ç”¨
    let triggerImageExplanation = false;
    
    // æ‹¡å¼µEmbeddingæ©Ÿèƒ½ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆã¯ãã¡ã‚‰ã‚’ä½¿ç”¨
    if (global.enhancedImageDecision) {
      try {
        // å‰ã®å¿œç­”ã‚’å–å¾—ï¼ˆå¯èƒ½ãªå ´åˆï¼‰
        let previousResponse = null;
        if (historyForProcessing && historyForProcessing.length > 0) {
          for (let i = historyForProcessing.length - 1; i >= 0; i--) {
            if (historyForProcessing[i].role === 'assistant') {
              previousResponse = historyForProcessing[i].content;
              break;
            }
          }
        }
        
        // æ‹¡å¼µåˆ¤å®šã‚’ä½¿ç”¨
        const enhancedDecision = await global.enhancedImageDecision.shouldGenerateImage(userMessage, previousResponse);
        if (enhancedDecision) {
          console.log(`[DEBUG] Enhanced image generation decision triggered for: "${userMessage}"`);
          triggerImageExplanation = true;
        }
      } catch (error) {
        console.error('[ERROR] Enhanced image decision failed, falling back to standard method:', error.message);
        // å¾“æ¥ã®æ–¹æ³•ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        if (isConfusionRequest(userMessage)) {
          console.log(`[DEBUG] Fallback: Direct image request detected in message: "${userMessage}"`);
          triggerImageExplanation = true;
        }
      }
    }
    // æ‹¡å¼µæ©Ÿèƒ½ãŒåˆ©ç”¨ã§ããªã„å ´åˆã¯å¾“æ¥ã®æ–¹æ³•ã‚’ä½¿ç”¨
    else if (isConfusionRequest(userMessage)) {
      console.log(`[DEBUG] Direct image request detected in message: "${userMessage}"`);
      triggerImageExplanation = true;
    }
    
    // ãã‚Œä»¥å¤–ã®ã™ã¹ã¦ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯LLMã§åˆ†æ
    if (!triggerImageExplanation) {
      try {
        console.log(`[DEBUG] Analyzing if user understands AI response: "${userMessage}"`);
        
        // ç›´å‰ã®AIå›ç­”ã‚’å–å¾—ã™ã‚‹
        // ä¼šè©±å±¥æ­´ã‹ã‚‰ç›´å‰ã®ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å–å¾—
        const lastAssistantMessage = historyForProcessing && historyForProcessing.length > 0 
          ? historyForProcessing.filter(item => item.role === 'assistant').pop() 
          : null;
        
        // lastAssistantMessageãŒæœªå®šç¾©ã®å ´åˆã€ä¼šè©±å±¥æ­´ã‹ã‚‰å–å¾—ã‚’è©¦ã¿ã‚‹
        let previousAIResponse = null;
        
        if (lastAssistantMessage && lastAssistantMessage.content) {
          previousAIResponse = lastAssistantMessage.content;
          console.log(`[DEBUG-IMAGE] Using cached lastAssistantMessage: "${previousAIResponse.substring(0, 30)}..."`);
        } else if (historyForProcessing && historyForProcessing.length > 0) {
          // ä¼šè©±å±¥æ­´ã‹ã‚‰æœ€æ–°ã®ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ¤œç´¢
          for (let i = historyForProcessing.length - 1; i >= 0; i--) {
            if (historyForProcessing[i].role === 'assistant') {
              previousAIResponse = historyForProcessing[i].content;
              console.log(`[DEBUG-IMAGE] Found assistant message in history: "${previousAIResponse.substring(0, 30)}..."`);
              break;
            }
          }
        }
        
        // ç›´å‰ã®AIå›ç­”ãŒãªã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
        if (!previousAIResponse) {
          console.log(`[DEBUG-IMAGE] No previous AI response found in cache or history, skipping confusion detection`);
        } else {
          // OpenAI APIã‚’ä½¿ç”¨ã—ã¦æ··ä¹±åº¦ã‚’åˆ¤å®š
          const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
          
          const systemPrompt = `ã‚ãªãŸã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¨AIã®ä¼šè©±ã‚’åˆ†æã—ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒAIã®ç™ºè¨€ã‚’ç†è§£ã§ãã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’åˆ¤æ–­ã™ã‚‹å°‚é–€å®¶ã§ã™ã€‚

ã‚ãªãŸã®ä»»å‹™ã¯ã€ã€Œãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒAIã®ç›´å‰ã®å›ç­”ã‚’ç†è§£ã—ã¦ã„ãªã„ã‹ã©ã†ã‹ã€ã‚’åˆ¤æ–­ã™ã‚‹ã“ã¨ã§ã™ã€‚
ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ç™ºè¨€ã‹ã‚‰ã€AIã®å›ç­”ã«å¯¾ã™ã‚‹æ··ä¹±ã‚„ç†è§£å›°é›£ãŒç¤ºã•ã‚Œã¦ã„ã‚‹ã¨åˆ¤æ–­ã§ãã‚‹å ´åˆã¯ã€ãã®ç¢ºåº¦ï¼ˆ0ã€œ100%ï¼‰ã‚’è©•ä¾¡ã—ã¦ãã ã•ã„ã€‚

ç¢ºåº¦ãŒ95%ä»¥ä¸Šã®å ´åˆã®ã¿ã€ŒCONFUSED:95ã€ã¨å›ç­”ã—ã€ãã‚Œä»¥å¤–ã¯ã€ŒNOT_CONFUSEDã€ã¨å›ç­”ã—ã¦ãã ã•ã„ã€‚

åˆ¤æ–­ã®éš›ã¯ã€ä»¥ä¸‹ã®ãƒã‚¤ãƒ³ãƒˆã«æ³¨æ„ã—ã¦ãã ã•ã„ï¼š
1. ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ç™ºè¨€ãŒAIã®å›ç­”å†…å®¹ã«é–¢é€£ã—ã¦ã„ã‚‹ã‹
2. ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã€Œã‚ã‹ã‚‰ãªã„ã€ã€Œç†è§£ã§ããªã„ã€ãªã©ã®è¡¨ç¾ã‚’ä½¿ã£ã¦ã„ã‚‹ã‹
3. ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒèª¬æ˜ã®ç°¡ç•¥åŒ–ã‚„åˆ¥ã®è¨€ã„æ–¹ã‚’æ±‚ã‚ã¦ã„ã‚‹ã‹
4. ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è³ªå•ãŒAIã®å›ç­”å†…å®¹ã‚’æ­£ã—ãç†è§£ã—ã¦ã„ãªã„ã“ã¨ã‚’ç¤ºã—ã¦ã„ã‚‹ã‹

ã€Œå„„åŠ«ã€ãªã©ã®è¡¨ç¾ã¯é€šå¸¸ã€æ··ä¹±ã§ã¯ãªãå˜ã«æ°—ãŒé€²ã¾ãªã„ã¨ã„ã†æ„å‘³ãªã®ã§æ··ä¹±ã¨ã¯åˆ¤æ–­ã—ãªã„ã§ãã ã•ã„ã€‚
ç´”ç²‹ã«ä¼šè©±ã‚’ç¶™ç¶šã™ã‚‹æ„å›³ã®ç™ºè¨€ã¯æ··ä¹±ã¨ã¿ãªã•ãªã„ã§ãã ã•ã„ã€‚

å›ç­”ã¯ã€ŒCONFUSED:95ã€ã¾ãŸã¯ã€ŒNOT_CONFUSEDã€ã®å½¢å¼ã®ã¿ã§è¿”ã—ã¦ãã ã•ã„ã€‚`;

          // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é…åˆ—ã‚’ä½œæˆ
          const messages = [
            { role: "system", content: systemPrompt },
            { role: "system", content: `ç›´å‰ã®AIã®å›ç­”: "${previousAIResponse.substring(0, 500)}${previousAIResponse.length > 500 ? '...' : ''}"` },
            { role: "user", content: userMessage }
          ];
          
          const response = await openai.chat.completions.create({
            model: "gpt-4o-mini",
            messages: messages,
            max_tokens: 10,
            temperature: 0.0
          });
          
          const content = response.choices[0].message.content.trim();
          console.log(`[DEBUG] LLM understanding analysis result: ${content}`);
          
          if (content.startsWith('CONFUSED:')) {
            const confidenceParts = content.split(':');
            if (confidenceParts.length > 1) {
              const confidence = parseFloat(confidenceParts[1]);
              if (confidence >= 95) {
                console.log(`[DEBUG] LLM determined user doesn't understand AI response with high confidence (${confidence}%)`);
                triggerImageExplanation = true;
              } else {
                console.log(`[DEBUG] LLM detected some confusion but confidence too low (${confidence}%)`);
              }
            }
          }
        }
      } catch (error) {
        console.error(`[DEBUG] Error in LLM understanding analysis: ${error.message}`);
      }
    }

    if (triggerImageExplanation) {
      console.log(`[DEBUG-IMAGE] Image explanation triggered for user ${userId}`);
      
      // Check if this user recently received an image generation - if so, skip image generation prompt
      const recentImageTimestamp = recentImageGenerationUsers.get(userId);
      if (recentImageTimestamp) {
        console.log(`[DEBUG-IMAGE] User ${userId} has recent image timestamp: ${recentImageTimestamp}, now: ${Date.now()}, diff: ${Date.now() - recentImageTimestamp}ms`);
      }
      
      if (recentImageTimestamp && (Date.now() - recentImageTimestamp < 30000)) { // 30 seconds protection
        console.log(`[DEBUG-IMAGE] User ${userId} recently received image generation, skipping image explanation offer`);
        recentImageGenerationUsers.delete(userId); // Clean up after use
        return;
      }
      
      // ä¼šè©±å±¥æ­´ã‹ã‚‰ç›´å‰ã®ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å–å¾—
      const lastAssistantMessage = historyForProcessing && historyForProcessing.length > 0 
        ? historyForProcessing.filter(item => item.role === 'assistant').pop() 
        : null;
      
      // lastAssistantMessageã®å–å¾—ã‚’è©¦ã¿ã‚‹ï¼ˆæœªå®šç¾©ã®å ´åˆã¯å±¥æ­´ã‹ã‚‰å–å¾—ï¼‰
      let contentToExplain = null;
      let contentSource = "unknown";
      
      if (lastAssistantMessage && lastAssistantMessage.content) {
        contentToExplain = lastAssistantMessage.content;
        contentSource = "cached";
        console.log(`[DEBUG-IMAGE] Using cached lastAssistantMessage for explanation: "${contentToExplain.substring(0, 30)}..."`);
      } else if (historyForProcessing && historyForProcessing.length > 0) {
        // å±¥æ­´ã‹ã‚‰æœ€æ–°ã®ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ¤œç´¢
        for (let i = historyForProcessing.length - 1; i >= 0; i--) {
          if (historyForProcessing[i].role === 'assistant') {
            contentToExplain = historyForProcessing[i].content;
            contentSource = "history";
            console.log(`[DEBUG-IMAGE] Using message from history for explanation: "${contentToExplain.substring(0, 30)}..."`);
            break;
          }
        }
      }
      
      if (contentToExplain) {
        console.log(`[DEBUG-IMAGE] Setting pendingImageExplanations for user ${userId} with content from ${contentSource}: "${contentToExplain.substring(0, 30)}..."`);
        // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ä»˜ãã§ä¿å­˜
        pendingImageExplanations.set(userId, {
          content: contentToExplain,
          timestamp: Date.now(),
          source: contentSource
        });
        // ç”»åƒç”Ÿæˆææ¡ˆçŠ¶æ…‹ã‚’ConversationHistoryã«è¨˜éŒ²
        await storeInteraction(userId, 'system', `[ç”»åƒç”Ÿæˆææ¡ˆ] ææ¡ˆæ™‚åˆ»: ${new Date().toISOString()}, ã‚½ãƒ¼ã‚¹: ${contentSource}`);
      } else {
        console.log(`[DEBUG-IMAGE] No content found for explanation, using default message`);
        pendingImageExplanations.set(userId, {
          content: "æ—¥å¸¸ä¼šè©±ã®åŸºæœ¬ã¨ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒã‚¤ãƒ³ãƒˆ",
          timestamp: Date.now(),
          source: "default"
        });
        // ç”»åƒç”Ÿæˆææ¡ˆçŠ¶æ…‹ã‚’ConversationHistoryã«è¨˜éŒ²
        await storeInteraction(userId, 'system', `[ç”»åƒç”Ÿæˆææ¡ˆ] ææ¡ˆæ™‚åˆ»: ${new Date().toISOString()}, ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ†ã‚­ã‚¹ãƒˆä½¿ç”¨`);
      }
      
      const suggestionMessage = "å‰å›ã®å›ç­”ã«ã¤ã„ã¦ã€ç”»åƒã«ã‚ˆã‚‹èª¬æ˜ã‚’ç”Ÿæˆã—ã¾ã—ã‚‡ã†ã‹ï¼Ÿã€Œã¯ã„ã€ã¾ãŸã¯ã€Œã„ã„ãˆã€ã§ãŠç­”ãˆãã ã•ã„ã€‚";
      console.log(`[DEBUG-IMAGE] ç”»åƒã«ã‚ˆã‚‹èª¬æ˜ã®ææ¡ˆã‚’ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«é€ä¿¡: "${suggestionMessage}"`);
      
      await storeInteraction(userId, 'assistant', suggestionMessage);
      return client.replyMessage(event.replyToken, {
        type: 'text',
        text: suggestionMessage
      });
    }

    // é€šå¸¸ã®ãƒ†ã‚­ã‚¹ãƒˆå‡¦ç†ã¸é€²ã‚€
    await storeInteraction(userId, 'user', userMessage);

    const historyForAIProcessing = await fetchUserHistory(userId, limit);
    // systemPrompt is already defined above

    // ã‚¢ãƒ‰ãƒã‚¤ã‚¹è¦æ±‚ã®æ¤œå‡ºï¼ˆéåŒæœŸå‡¦ç†ã«å¯¾å¿œï¼‰
    const adviceRequested = await detectAdviceRequestWithLLM(userMessage, historyForAIProcessing);
    
    // ä¼šè©±å±¥æ­´å–å¾—ã®ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°
    console.log(`[ä¼šè©±å±¥æ­´è¨ºæ–­] ãƒ¦ãƒ¼ã‚¶ãƒ¼: ${userId}, ãƒ¢ãƒ¼ãƒ‰: ${mode}, å–å¾—å±¥æ­´æ•°: ${historyForAIProcessing.history?.length || 0}ä»¶`);
    
    // systemPrompt is already defined above
    
    // ã‚µãƒ¼ãƒ“ã‚¹è¡¨ç¤ºã®åˆ¤æ–­
    const showServices = await shouldShowServicesToday(userId, historyForAIProcessing, userMessage);

    // AIã§ã®å‡¦ç†ã‚’å®Ÿè¡Œ
    const result = await processWithAI(systemPrompt, userMessage, historyForAIProcessing, mode, userId, client);
    
    // ã‚µãƒ¼ãƒ“ã‚¹æ¨å¥¨ãŒã‚ã‚‹å ´åˆã€ãã‚Œã‚’å¿œç­”ã«è¿½åŠ 
    let finalResponse = result.response;
    
    // å¿œç­”ãŒç©ºã®å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆLINE APIã®400ã‚¨ãƒ©ãƒ¼é˜²æ­¢ï¼‰
    if (!finalResponse || finalResponse.trim() === '') {
      console.log(`âš ï¸ è­¦å‘Š: AIã‹ã‚‰ç©ºã®å¿œç­”ã‚’å—ã‘å–ã‚Šã¾ã—ãŸã€‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚`);
      finalResponse = "ç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ã€å‡¦ç†ä¸­ã«å•é¡ŒãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã—ã°ã‚‰ãçµŒã£ã¦ã‹ã‚‰ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚";
    }
    
    const serviceRecommendations = result.recommendations;
    
    if (serviceRecommendations && serviceRecommendations.length > 0) {
      console.log(`Adding ${serviceRecommendations.length} service recommendations to response`);
      
      // ã‚µãƒ¼ãƒ“ã‚¹æ¨å¥¨ã®è¡¨ç¤ºç”¨ã‚«ãƒ†ã‚´ãƒªã‚’æ±ºå®š
      const category = mode === 'mental_health' ? 'mental_health' : 
                      mode === 'career' ? 'career' : 'general';
      
      // è‡ªç„¶ãªç§»è¡Œãƒ†ã‚­ã‚¹ãƒˆã‚’ä½œæˆ
      const transitionText = createNaturalTransition(finalResponse, category, false);
      
      // ã‚µãƒ¼ãƒ“ã‚¹æƒ…å ±ã‚’æ§‹ç¯‰
      let serviceText = '';
      
      // æœ€å¤§3ã¤ã®ã‚µãƒ¼ãƒ“ã‚¹ã‚’è¡¨ç¤º
      const displayServices = serviceRecommendations.slice(0, 3);
      
      // ã‚µãƒ¼ãƒ“ã‚¹æƒ…å ±ã‚’è¿½åŠ 
      displayServices.forEach((service, index) => {
        // ã‚µãƒ¼ãƒ“ã‚¹åã®å–å¾—
        let serviceName;
        let serviceDescription = '';
        let serviceUrl = '';
        
        if (typeof service === 'string') {
          // ã‚µãƒ¼ãƒ“ã‚¹IDã‹ã‚‰ã‚µãƒ¼ãƒ“ã‚¹æƒ…å ±ã‚’å–å¾—
          const serviceInfo = servicesData.find(s => s.id === service);
          if (serviceInfo) {
            serviceName = serviceInfo.name;
            serviceDescription = serviceInfo.description;
            serviceUrl = serviceInfo.url;
          } else {
            serviceName = service;
          }
        } else if (service.name) {
          serviceName = service.name;
          serviceDescription = service.description || '';
          serviceUrl = service.url || '';
        } else if (service.serviceName) {
          serviceName = service.serviceName;
          serviceDescription = service.description || '';
          serviceUrl = service.url || '';
        } else if (service.id) {
          // ã‚µãƒ¼ãƒ“ã‚¹IDã‹ã‚‰ã‚µãƒ¼ãƒ“ã‚¹æƒ…å ±ã‚’å–å¾—
          const serviceInfo = servicesData.find(s => s.id === service.id);
          if (serviceInfo) {
            serviceName = serviceInfo.name;
            serviceDescription = serviceInfo.description;
            serviceUrl = serviceInfo.url;
          } else {
            serviceName = service.id;
          }
        }
        
        // ã‚µãƒ¼ãƒ“ã‚¹æƒ…å ±ã‚’ãƒ†ã‚­ã‚¹ãƒˆã«è¿½åŠ 
        serviceText += `${index + 1}. ${serviceName}`;
        if (serviceUrl) {
          serviceText += `\n   URL: ${serviceUrl}`;
        }
        if (serviceDescription) {
          // èª¬æ˜æ–‡ã®åˆ‡ã‚Šæ¨ã¦é•·ã•ã‚’80ã‹ã‚‰150ã«æ‹¡å¤§ã—ã€ã‚ˆã‚Šè‡ªç„¶ãªåˆ‡ã‚Šæ¨ã¦ã‚’å®Ÿç¾
          const maxDescLength = 150;
          let trimmedDesc = serviceDescription;
          if (serviceDescription.length > maxDescLength) {
            // æ–‡ã®åŒºåˆ‡ã‚Šã§åˆ‡ã‚‹
            const lastSentenceEnd = serviceDescription.substring(0, maxDescLength).lastIndexOf('ã€‚');
            if (lastSentenceEnd > maxDescLength * 0.7) { // 70%ä»¥ä¸Šã®ä½ç½®ã«ã‚ã‚‹å ´åˆ
              trimmedDesc = serviceDescription.substring(0, lastSentenceEnd + 1) + '...';
            } else {
              trimmedDesc = serviceDescription.substring(0, maxDescLength) + '...';
            }
          }
          serviceText += `\n   ${trimmedDesc}`;
        }
        serviceText += '\n\n'; // ã‚µãƒ¼ãƒ“ã‚¹é–“ã®åŒºåˆ‡ã‚Šã‚’æ”¹å–„
      });
      
      // æœ€çµ‚çš„ãªå¿œç­”ã‚’æ§‹ç¯‰
      finalResponse = `${finalResponse}${transitionText}${serviceText}`;
      
      // æ¨å¥¨ã•ã‚ŒãŸã‚µãƒ¼ãƒ“ã‚¹ã‚’è¨˜éŒ²ï¼ˆå°†æ¥ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯è¿½è·¡ã®ãŸã‚ï¼‰
      const preferences = userPreferences.getUserPreferences(userId);
      if (preferences) {
        const timestamp = Date.now().toString();
        const serviceIds = displayServices.map(service => 
          typeof service === 'string' ? service : 
          service.id ? service.id : 
          service.serviceName ? service.serviceName : '');
          
        // ä»¥å‰ã®è¡¨ç¤ºæ¸ˆã¿ã‚µãƒ¼ãƒ“ã‚¹æƒ…å ±ã‚’èª­ã¿è¾¼ã¿
        preferences.recentlyShownServices = preferences.recentlyShownServices || {};
        
        // æ–°ã—ã„è¡¨ç¤ºæ¸ˆã¿ã‚µãƒ¼ãƒ“ã‚¹æƒ…å ±ã‚’è¿½åŠ 
        preferences.recentlyShownServices[timestamp] = serviceIds;
        
        // ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šã‚’æ›´æ–°
        userPreferences.updateUserPreferences(userId, preferences);
      }
    }
    
    // ã‚µãƒ¼ãƒ“ã‚¹æ¨å¥¨ãŒè¡¨ç¤ºã•ã‚Œãªã„ç†ç”±ã‚’ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«é€šçŸ¥ã™ã‚‹ãŸã‚ã®é–¢æ•°
    function getServiceNotificationMessage(userId, showServiceReason) {
      // é€šçŸ¥ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ - å®Ÿéš›ã®UIè¡¨ç¤ºã«ã¯ä½¿ç”¨ã›ãšã€å†…éƒ¨çš„ã«è¨˜éŒ²ã®ã¿
      if (!showServiceReason) {
        return null; // ç†ç”±ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ä½•ã‚‚è¡¨ç¤ºã—ãªã„
      }

      const userPrefs = userPreferences.getUserPreferences(userId);
      
      switch (showServiceReason) {
        case 'disabled':
          return 'ï¼ˆç¾åœ¨ã‚µãƒ¼ãƒ“ã‚¹æ¨å¥¨ã¯ç„¡åŠ¹ã«ãªã£ã¦ã„ã¾ã™ã€‚ã€Œã‚µãƒ¼ãƒ“ã‚¹è¡¨ç¤ºã‚ªãƒ³ã€ã¨å…¥åŠ›ã™ã‚‹ã¨æœ‰åŠ¹ã«ãªã‚Šã¾ã™ï¼‰';
        case 'no_request':
          return 'ï¼ˆæ˜ç¤ºçš„ãªã‚¢ãƒ‰ãƒã‚¤ã‚¹è¦æ±‚ãŒãªã„å ´åˆã€ã‚µãƒ¼ãƒ“ã‚¹æ¨å¥¨ã¯è¡¨ç¤ºã•ã‚Œã¾ã›ã‚“ã€‚ã€Œã‚¢ãƒ‰ãƒã‚¤ã‚¹ãã ã•ã„ã€ãªã©ã¨å…¥åŠ›ã™ã‚‹ã¨è¡¨ç¤ºã•ã‚Œã¾ã™ï¼‰';
        case 'daily_limit':
          return 'ï¼ˆ1æ—¥ã®æ¨å¥¨ä¸Šé™ã«é”ã—ã¾ã—ãŸã€‚æ˜æ—¥ä»¥é™ã«å†åº¦ã”åˆ©ç”¨ãã ã•ã„ï¼‰';
        case 'cooldown':
          return 'ï¼ˆæœ€è¿‘ã‚µãƒ¼ãƒ“ã‚¹ã‚’æ¨å¥¨ã—ãŸãŸã‚ã€ã—ã°ã‚‰ãè¡¨ç¤ºã‚’æ§ãˆã¦ã„ã¾ã™ã€‚å°‘ã—æ™‚é–“ã‚’ãŠã„ã¦ã‹ã‚‰å†åº¦ãŠè©¦ã—ãã ã•ã„ï¼‰';
        default:
          return null;
      }
    }

    // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã¨ã—ã¦è¡¨ç¤ºã•ã‚Œãªã„ç†ç”±ã‚’å–å¾—
    // (serviceNotificationReasonã®åˆæœŸåŒ–ãŒä¸è¶³ã—ã¦ã„ãŸãŸã‚ã€ã“ã“ã§é©åˆ‡ã«è¨­å®š)
    let serviceNotificationReason = null;
    
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šã‚’å–å¾—
    const userPrefs = userPreferences.getUserPreferences(userId);
    
    // ã‚µãƒ¼ãƒ“ã‚¹è¡¨ç¤ºãŒã‚ªãƒ•ã®å ´åˆã«ç†ç”±ã‚’è¨­å®š
    if (!showServices && userPrefs && !userPrefs.showServiceRecommendations) {
      serviceNotificationReason = 'disabled';
    } else if (!showServices && !adviceRequested) {
      serviceNotificationReason = 'no_request';
    }
    
    // ã‚µãƒ¼ãƒ“ã‚¹æ¨å¥¨ã®é€šçŸ¥ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å–å¾—
    const notificationMessage = getServiceNotificationMessage(userId, serviceNotificationReason);
    if (notificationMessage) {
      console.log('Service notification message (debug only):', notificationMessage);
      // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã®ã¿ã€AIã®å¿œç­”ã«è¿½è¨˜ï¼ˆæœ¬ç•ªç’°å¢ƒã§ã¯è¡¨ç¤ºã—ãªã„ï¼‰
      if (process.env.DEBUG_MODE === 'true') {
        finalResponse += '\n\n' + notificationMessage;
      }
    }
    
    // LINEã®ãƒªãƒ—ãƒ©ã‚¤å‡¦ç†
    console.log(`Replying to ${event.replyToken} with message: ${finalResponse.substring(0, 50)}...`);
    
    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒç©ºã§ãªã„ã“ã¨ã‚’ç¢ºèª
    if (!finalResponse || finalResponse.trim() === '') {
      finalResponse = "ç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ã€ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚å¾Œã§ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚";
      console.error(`âš  LINEé€ä¿¡ç›´å‰ã«ç©ºã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ¤œå‡ºã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ç½®ãæ›ãˆã¾ã—ãŸã€‚`);
    }
    
    try {
      await client.replyMessage(event.replyToken, {
        type: 'text',
        text: finalResponse
      });
    } catch (replyError) {
      console.error(`LINEå¿œç­”é€ä¿¡ã‚¨ãƒ©ãƒ¼: ${replyError.message}`);
      console.error(`å¿œç­”ã®é•·ã•: ${finalResponse.length}æ–‡å­—`);
      
      // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒé•·ã™ãã‚‹å ´åˆã¯åˆ†å‰²ã—ã¦é€ä¿¡ã‚’è©¦ã¿ã‚‹
      if (finalResponse.length > 5000) {
        try {
          const shortenedResponse = finalResponse.substring(0, 4000) + "\n\n(ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒé•·ã™ãã‚‹ãŸã‚çœç•¥ã•ã‚Œã¾ã—ãŸ)";
          await client.replyMessage(event.replyToken, {
            type: 'text',
            text: shortenedResponse
          });
          console.log(`é•·ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’çŸ­ç¸®ã—ã¦é€ä¿¡ã—ã¾ã—ãŸã€‚`);
        } catch (fallbackError) {
          console.error(`çŸ­ç¸®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ã«ã‚‚å¤±æ•—: ${fallbackError.message}`);
        }
      }
    }
  } catch (error) {
    console.error('Error handling text message:', error);
    return Promise.resolve(null);
  }
}

// ã‚µãƒ¼ãƒãƒ¼èµ·å‹•è¨­å®š
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Listening on port ${PORT}`);
  console.log(`Visit: http://localhost:${PORT} (if local)\n`);
});

/**
 * Checks if a message indicates user confusion or a request for explanation about an image
 * Now only checks for direct image analysis requests
 * @param {string} text - The message text to check
 * @return {boolean} - True if the message is a direct request for image analysis
 */
function isConfusionRequest(text) {
  // ç›´æ¥çš„ãªç”»åƒåˆ†æãƒªã‚¯ã‚¨ã‚¹ãƒˆã‹ã©ã†ã‹ã‚’åˆ¤æ–­ã™ã‚‹ã ã‘ã®æ©Ÿèƒ½ã«å¤‰æ›´
  // äº’æ›æ€§ã®ãŸã‚ã«é–¢æ•°åã¯å¤‰æ›´ã›ãš
  if (!text || typeof text !== 'string') return false;
  
  // æ˜ã‚Šä¸‹ã’ãƒ¢ãƒ¼ãƒ‰ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã¯é™¤å¤–
  if (isDeepExplorationRequest(text)) {
    return false;
  }
  
  // ç”»åƒç”Ÿæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ãƒã‚§ãƒƒã‚¯
  const imageGenerationRequests = [
    'ç”»åƒã‚’ç”Ÿæˆ', 'ç”»åƒã‚’ä½œæˆ', 'ç”»åƒã‚’ä½œã£ã¦', 'ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’ç”Ÿæˆ', 'ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’ä½œæˆ', 'ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’ä½œã£ã¦',
    'å›³ã‚’ç”Ÿæˆ', 'å›³ã‚’ä½œæˆ', 'å›³ã‚’ä½œã£ã¦', 'å›³è§£ã—ã¦', 'å›³è§£ã‚’ä½œæˆ', 'å›³è§£ã‚’ç”Ÿæˆ',
    'ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«åŒ–ã—ã¦', 'è¦–è¦šåŒ–ã—ã¦', 'çµµã‚’æã„ã¦', 'çµµã‚’ç”Ÿæˆ', 'çµµã‚’ä½œæˆ',
    'ç”»åƒã§èª¬æ˜', 'ã‚¤ãƒ¡ãƒ¼ã‚¸ã§èª¬æ˜', 'å›³ã§èª¬æ˜', 'è¦–è¦šçš„ã«èª¬æ˜',
    'ç”»åƒã«ã—ã¦', 'ã‚¤ãƒ©ã‚¹ãƒˆã‚’ä½œæˆ', 'ã‚¤ãƒ©ã‚¹ãƒˆã‚’ç”Ÿæˆ', 'ã‚¤ãƒ©ã‚¹ãƒˆã‚’æã„ã¦'
  ];
  
  // ç”»åƒç”Ÿæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆã¾ãŸã¯ç”»åƒåˆ†æãƒªã‚¯ã‚¨ã‚¹ãƒˆã®å ´åˆã¯trueã‚’è¿”ã™
  return imageGenerationRequests.some(phrase => text.includes(phrase)) || isDirectImageAnalysisRequest(text);
}

/**
 * Handles vision explanation requests
 * @param {Object} event - The LINE event object
 * @return {Promise<void>}
 */
async function handleVisionExplanation(event, explanationText) {
  const userId = event.source.userId;
  
  // Mark this user as having image generation in progress
  imageGenerationInProgress.set(userId, true);
  console.log(`Starting image generation for user ${userId} - setting protection flag`);
  
  // ç”»åƒç”Ÿæˆé–‹å§‹ã‚’è¨˜éŒ²
  await storeInteraction(userId, 'system', `[ç”»åƒç”Ÿæˆé–‹å§‹] ${new Date().toISOString()}`);
  
  try {
    // explanationTextãŒæä¾›ã•ã‚Œã¦ã„ã‚‹å ´åˆã€ãã‚Œã‚’ä½¿ç”¨ã—ã¦ç”»åƒèª¬æ˜ã‚’ç”Ÿæˆ
    if (explanationText) {
      // Check if this is a long text like the ASD guide and summarize if needed
      let displayText = explanationText;
      let enhancedPrompt = "";
      let isASDGuide = false;
      
      // If text is very long (like the ASD guide), create a summary version
      if (explanationText.length > 300) {
        console.log(`[DEBUG] Long text detected (${explanationText.length} chars), creating summary version`);
        
        // Check if it's the ASD guide
        if (explanationText.includes("ASDæ”¯æ´æ©Ÿèƒ½ã®ä½¿ã„æ–¹ã‚¬ã‚¤ãƒ‰") || explanationText.includes("è‡ªé–‰ç—‡ã‚¹ãƒšã‚¯ãƒˆãƒ©ãƒ éšœå®³")) {
          isASDGuide = true;
          displayText = "ASDæ”¯æ´æ©Ÿèƒ½ã®æ´»ç”¨æ–¹æ³•";
          enhancedPrompt = "ASDï¼ˆè‡ªé–‰ç—‡ã‚¹ãƒšã‚¯ãƒˆãƒ©ãƒ éšœå®³ï¼‰æ”¯æ´ã®ä¸»è¦ãªãƒã‚¤ãƒ³ãƒˆã‚’ç°¡æ½”ã«ç¤ºã—ãŸè¦–è¦šçš„ãªå›³è§£ã€‚è³ªå•ä¾‹ï¼ˆã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã€æ„Ÿè¦šéæ•ã€ç¤¾ä¼šå ´é¢ãªã©ã®å¯¾å¿œï¼‰ã€åŸºæœ¬çš„ãªä½¿ã„æ–¹ã€æ³¨æ„ç‚¹ã‚’å«ã‚€ã€‚ã‚·ãƒ³ãƒ—ãƒ«ã§åˆ†ã‹ã‚Šã‚„ã™ã„ã‚¤ãƒ³ãƒ•ã‚©ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯å½¢å¼ã€‚";
          console.log(`[DEBUG] ASD guide detected, using specialized summary and prompt`);
        } else {
          // For other long texts, extract the first sentence or first 100 chars
          displayText = explanationText.split('ã€‚')[0] + "ã€‚";
          if (displayText.length > 100) {
            displayText = displayText.substring(0, 97) + "...";
          }
          enhancedPrompt = `ä»¥ä¸‹ã®å†…å®¹ã®è¦ç‚¹ã‚’è¦–è¦šçš„ã«èª¬æ˜ã™ã‚‹ã‚¤ãƒ©ã‚¹ãƒˆ: ${explanationText.substring(0, 500)}`;
        }
      } else if (explanationText.length <= 20) {
        // çŸ­ã„ãƒ†ã‚­ã‚¹ãƒˆã®å ´åˆã¯æ•™è‚²çš„ãªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’è¿½åŠ 
        console.log(`[DEBUG] Short text detected (${explanationText.length} chars), adding educational context`);
        displayText = explanationText;
        enhancedPrompt = `ã€Œ${explanationText}ã€ã«ã¤ã„ã¦ã®æ•™è‚²çš„ã§åˆ†ã‹ã‚Šã‚„ã™ã„å›³è§£ã€‚æ—¥å¸¸ç”Ÿæ´»ã§ã®å¿œç”¨ä¾‹ã‚„åŸºæœ¬æ¦‚å¿µã‚’å«ã‚€ã€æ˜ã‚‹ãè¦ªã—ã¿ã‚„ã™ã„ã‚¤ãƒ©ã‚¹ãƒˆã€‚`;
      } else {
        // For normal length text, use as is
        enhancedPrompt = `ä»¥ä¸‹ã®ãƒ†ã‚­ã‚¹ãƒˆã«åŸºã¥ã„ã¦è©³ç´°ã§ã€ã‚ã‹ã‚Šã‚„ã™ã„ã‚¤ãƒ©ã‚¹ãƒˆã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚ãƒ†ã‚­ã‚¹ãƒˆ: ${explanationText}`;
      }
      
      // Use a simple message for generation notification
      let generationMessage = isASDGuide 
        ? "ASDæ”¯æ´æ©Ÿèƒ½ã®ä¸»ãªãƒã‚¤ãƒ³ãƒˆã‚’è¦–è¦šåŒ–ã—ã¦ã„ã¾ã™ã€‚å°‘ã€…ãŠå¾…ã¡ãã ã•ã„..."
        : `ã€Œ${displayText}ã€ã«åŸºã¥ãè¦–è¦šçš„ãªèª¬æ˜ã‚’ç”Ÿæˆã—ã¦ã„ã¾ã™ã€‚å°‘ã€…ãŠå¾…ã¡ãã ã•ã„...`;
      
      await client.replyMessage(event.replyToken, {
        type: 'text',
        text: generationMessage
      });
      
      // DALL-Eã‚’ä½¿ç”¨ã—ã¦ç”»åƒã‚’ç”Ÿæˆ
      try {
        const openai = new OpenAI({
          apiKey: process.env.OPENAI_API_KEY
        });
        
        console.log(`[DEBUG] Using enhanced prompt: ${enhancedPrompt.substring(0, 100)}...`);
        
        const response = await openai.images.generate({
          model: "dall-e-3",
          prompt: enhancedPrompt,
          n: 1,
          size: "1024x1024",
          quality: "standard"
        });
        
        const imageUrl = response.data[0].url;
        
        // ç”Ÿæˆã•ã‚ŒãŸç”»åƒã®URLã‚’å–å¾—
        console.log(`Generated image URL: ${imageUrl}`);
        
        // Create a concise response message
        let responseMessage = "";
        if (isASDGuide) {
          responseMessage = "ASDæ”¯æ´æ©Ÿèƒ½ã®ä¸»ãªãƒã‚¤ãƒ³ãƒˆã‚’ã¾ã¨ã‚ãŸç”»åƒã§ã™ã€‚ã“ã®è¦–è¦šçš„ãªèª¬æ˜ã¯ç†è§£ã®åŠ©ã‘ã«ãªã‚Šã¾ã—ãŸã‹ï¼Ÿ";
        } else {
          responseMessage = `ã€Œ${displayText}ã€ã®è¦ç‚¹ã‚’è¦–è¦šåŒ–ã—ã¾ã—ãŸã€‚ã“ã®ç”»åƒã¯å‚è€ƒã«ãªã‚Šã¾ã—ãŸã‹ï¼Ÿ`;
        }
        
        // ç”»åƒã‚’LINEã«é€ä¿¡
        await client.pushMessage(userId, [
          {
            type: 'image',
            originalContentUrl: imageUrl,
            previewImageUrl: imageUrl
          },
          {
            type: 'text',
            text: responseMessage
          }
        ]);
        
        // ç”Ÿæˆã—ãŸç”»åƒæƒ…å ±ã‚’ä¿å­˜ - Store only image reference with concise text
        let storageText = isASDGuide ? "ASDæ”¯æ´æ©Ÿèƒ½ã®è¦–è¦šçš„ã‚¬ã‚¤ãƒ‰" : displayText;
        await storeInteraction(userId, 'assistant', `[ç”Ÿæˆç”»åƒ] ${storageText}`);
        await storeInteraction(userId, 'system', `[ç”»åƒç”Ÿæˆå®Œäº†] ${new Date().toISOString()}`);
        
        // Add user to recent image generation tracking with timestamp to prevent ASD guide
        recentImageGenerationUsers.set(userId, Date.now());
        console.log(`[DEBUG] Setting recentImageGenerationUsers timestamp for user ${userId}: ${Date.now()}`);
        
        // Clear the image generation flag after a delay (5 seconds should be enough)
        setTimeout(() => {
          imageGenerationInProgress.delete(userId);
          console.log(`Cleared image generation flag for user ${userId} after successful generation`);
          console.log(`[DEBUG] Image generation protection status - imageGenerationInProgress: ${imageGenerationInProgress.has(userId) ? 'YES' : 'NO'}, recentImageGenerationUsers timestamp: ${recentImageGenerationUsers.get(userId)}`);
        }, 5000);
        
      } catch (error) {
        console.error('DALL-Eç”»åƒç”Ÿæˆã‚¨ãƒ©ãƒ¼:', error);
        
        // ã‚¨ãƒ©ãƒ¼ã®ç¨®é¡ã«å¿œã˜ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æä¾›
        let errorMessage = 'ç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ã€‚ç”»åƒã®ç”Ÿæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚';
        
        // å®‰å…¨ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã‚‹æ‹’å¦ã®å ´åˆ
        if (error.code === 'content_policy_violation' || 
            (error.message && error.message.includes('safety system'))) {
          errorMessage = 'ç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰å®‰å…¨ãªç”»åƒã‚’ç”Ÿæˆã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ã€Œæ—¥å¸¸ä¼šè©±ã®ãƒã‚¤ãƒ³ãƒˆã€ã€Œã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®åŸºæœ¬ã€ãªã©ã®å…·ä½“çš„ãªãƒ†ãƒ¼ãƒã§è©¦ã—ã¦ã¿ã¦ãã ã•ã„ã€‚';
        } else {
          errorMessage += 'åˆ¥ã®è¡¨ç¾ã§è©¦ã—ã¦ã¿ã¦ãã ã•ã„ã€‚';
        }
        
        await client.pushMessage(userId, {
          type: 'text',
          text: errorMessage
        });
        
        // Also clear the flag in case of error
        imageGenerationInProgress.delete(userId);
        console.log(`Cleared image generation flag for user ${userId} due to error`);
      }
      
      return;
    }
    
    // explanationTextãŒãªã„å ´åˆã¯é€šå¸¸ã®ç”»åƒå±¥æ­´æ¤œç´¢å‡¦ç†ã‚’è¡Œã†
    // Get user's recent history to find the last image
    const history = await fetchUserHistory(userId, 10);
    
    // Find the most recent image message
    const lastImageMessage = history
      .filter(item => item.content && item.content.includes('ç”»åƒãŒé€ä¿¡ã•ã‚Œã¾ã—ãŸ'))
      .pop();
    
    if (!lastImageMessage) {
      // No recent image found
      await client.replyMessage(event.replyToken, {
        type: 'text',
        text: 'æœ€è¿‘ã®ç”»åƒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚èª¬æ˜ã—ã¦ã»ã—ã„ç”»åƒã‚’é€ä¿¡ã—ã¦ãã ã•ã„ã€‚ã‚‚ã—ç”»åƒã®èª¬æ˜ã‚’æ±‚ã‚ã¦ã„ãªã„å ´åˆã¯ã€åˆ¥ã®è³ªå•ã‚’ãŠé¡˜ã„ã—ã¾ã™ã€‚'
      });
      return;
    }

    // å‡¦ç†ä¸­ã§ã‚ã‚‹ã“ã¨ã‚’é€šçŸ¥
    await client.replyMessage(event.replyToken, {
      type: 'text',
      text: 'ç”»åƒã‚’åˆ†æã—ã¦ã„ã¾ã™ã€‚å°‘ã€…ãŠå¾…ã¡ãã ã•ã„...'
    });

    // ç”»åƒãƒ¡ãƒƒã‚»ãƒ¼ã‚¸IDã‚’æŠ½å‡º
    const messageIdMatch = lastImageMessage.content.match(/\(ID: ([^)]+)\)/);
    const messageId = messageIdMatch ? messageIdMatch[1] : null;
    
    if (!messageId) {
      throw new Error('ç”»åƒãƒ¡ãƒƒã‚»ãƒ¼ã‚¸IDãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
    }
    
    console.log(`Using image message ID: ${messageId} for analysis`);

    // LINE APIã‚’ä½¿ç”¨ã—ã¦ç”»åƒã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’å–å¾—
    const stream = await client.getMessageContent(messageId);
    
    // ç”»åƒãƒ‡ãƒ¼ã‚¿ã‚’ãƒãƒƒãƒ•ã‚¡ã«å¤‰æ›
    const chunks = [];
    for await (const chunk of stream) {
      chunks.push(chunk);
    }
    const imageBuffer = Buffer.concat(chunks);
    
    // Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
    const base64Image = imageBuffer.toString('base64');
    
    // OpenAI Vision APIã«é€ä¿¡ã™ã‚‹ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’æº–å‚™
    const openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
    
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "user",
          content: [
            { type: "text", text: "ã“ã®ç”»åƒã«ã¤ã„ã¦è©³ã—ãèª¬æ˜ã—ã¦ãã ã•ã„ã€‚ä½•ãŒå†™ã£ã¦ã„ã¦ã€ã©ã‚“ãªçŠ¶æ³ã‹ã€é‡è¦ãªè©³ç´°ã‚’æ•™ãˆã¦ãã ã•ã„ã€‚" },
            { 
              type: "image_url", 
              image_url: {
                url: `data:image/jpeg;base64,${base64Image}`
              }
            }
          ]
        }
      ],
      max_tokens: 500
    });
    
    const analysis = response.choices[0].message.content;
    console.log(`Image analysis completed for user ${userId}`);
    
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«åˆ†æçµæœã‚’é€ä¿¡
    await client.pushMessage(userId, {
      type: 'text',
      text: analysis
    });
    
    // ä¼šè©±å±¥æ­´ã«ç”»åƒåˆ†æã‚’è¨˜éŒ²
    await storeInteraction(userId, 'assistant', `[ç”»åƒåˆ†æ] ${analysis}`);
    
  } catch (error) {
    console.error('Error in handleVisionExplanation:', error);
    
    // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡
    try {
      await client.pushMessage(userId, {
        type: 'text',
        text: 'ç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ã€‚ç”»åƒã®åˆ†æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ' + error.message
      });
    } catch (replyError) {
      console.error('Error sending error reply:', replyError);
    }
  }
}

/**
 * Extracts relevant context from conversation history
 * @param {Array} history - Array of conversation history items
 * @param {string} userMessage - Current user message
 * @return {Object} - Extracted context information
 */
function extractConversationContext(history, userMessage) {
  // äº’æ›æ€§ã®ãŸã‚ã«åŒæœŸç‰ˆã‚‚ç¶­æŒ
  // éåŒæœŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’å‘¼ã³å‡ºã—ã€çµæœã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã™ã‚‹ãŒã€å³åº§ã«ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã‚’è¿”ã™
  
  // åŸºæœ¬çš„ãªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆæƒ…å ±
  const context = {
    userInterests: null,
    userEmotion: 'neutral',
    emotionIntensity: 0,
    messageCount: history.length,
    recentTopics: []
  };
  
  // éåŒæœŸå‡¦ç†ã‚’ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§é–‹å§‹
  extractConversationContextAsync(history, userMessage)
    .then(asyncResult => {
      // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«çµæœã‚’æ ¼ç´ï¼ˆä»–ã®å‘¼ã³å‡ºã—ã§å†åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã«ï¼‰
      if (!global.contextCache) {
        global.contextCache = new Map();
      }
      const cacheKey = getCacheKeyForContext(history, userMessage);
      global.contextCache.set(cacheKey, asyncResult);
    })
    .catch(error => {
      console.error('Error in async context extraction:', error);
    });
  
  // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯ãã‚Œã‚’ä½¿ç”¨
  if (global.contextCache) {
    const cacheKey = getCacheKeyForContext(history, userMessage);
    if (global.contextCache.has(cacheKey)) {
      return global.contextCache.get(cacheKey);
    }
  }
  
  // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒãªã„å ´åˆã¯å¾“æ¥ã®åŒæœŸãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨
  return extractConversationContextLegacy(history, userMessage);
}

/**
 * ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚­ãƒ¼ã‚’ç”Ÿæˆã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
 */
function getCacheKeyForContext(history, userMessage) {
  // æœ€æ–°ã®æ•°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‹ã‚‰ãƒãƒƒã‚·ãƒ¥ã‚’ç”Ÿæˆ
  const recentMessages = history.slice(-3).map(msg => msg.content).join('|');
  const textToHash = `${recentMessages}|${userMessage}`;
  
  return crypto.createHash('md5').update(textToHash).digest('hex');
}

/**
 * ä¼šè©±ã®æ–‡è„ˆã‚’æ„å‘³çš„ã«æŠ½å‡ºã™ã‚‹éåŒæœŸé–¢æ•°
 * @param {Array} history - ä¼šè©±å±¥æ­´
 * @param {string} userMessage - ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
 * @returns {Promise<Object>} - æŠ½å‡ºã•ã‚ŒãŸæ–‡è„ˆæƒ…å ±
 */
async function extractConversationContextAsync(history, userMessage) {
  try {
    // EmbeddingServiceã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å–å¾—ã¾ãŸã¯åˆæœŸåŒ–
    if (!global.embeddingService) {
      const EmbeddingService = require('./embeddingService');
      global.embeddingService = new EmbeddingService();
      await global.embeddingService.initialize();
    }
    
    // åŸºæœ¬çš„ãªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆæƒ…å ±
    const context = {
      userInterests: [],
      userEmotion: 'neutral',
      emotionIntensity: 0,
      messageCount: history.length,
      recentTopics: []
    };
    
    // æœ€è¿‘ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ½å‡ºï¼ˆæœ€å¤§5ä»¶ï¼‰
    const recentMessages = history.slice(-5);
    const recentUserMessages = recentMessages
      .filter(msg => msg.role === 'user')
      .map(msg => msg.content);
    
    // ç¾åœ¨ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å«ã‚€
    const allUserMessages = [...recentUserMessages, userMessage];
    const combinedUserText = allUserMessages.join(' ');
    
    // ãƒ†ã‚­ã‚¹ãƒˆãŒçŸ­ã™ãã‚‹å ´åˆã¯å¾“æ¥ã®æ–¹æ³•ã‚’ä½¿ç”¨
    if (combinedUserText.length < 20) {
      return extractConversationContextLegacy(history, userMessage);
    }
    
    // 1. æ„Ÿæƒ…åˆ†æ - æ„Ÿæƒ…ã‚«ãƒ†ã‚´ãƒªã¨ä¾‹æ–‡ã®ãƒãƒƒãƒ”ãƒ³ã‚°
    const emotionExamples = {
      positive: "ã¨ã¦ã‚‚å¬‰ã—ã„ã§ã™ã€‚ç´ æ™´ã‚‰ã—ã„æ°—åˆ†ã§ã™ã€‚ã‚ã‚ŠãŒã¨ã†ã€‚æ¥½ã—ã„ã§ã™ã€‚æœ€é«˜ã§ã™ã€‚",
      negative: "æ‚²ã—ã„ã§ã™ã€‚è¾›ã„ã§ã™ã€‚è‹¦ã—ã„ã§ã™ã€‚å›°ã£ã¦ã„ã¾ã™ã€‚å¿ƒé…ã§ã™ã€‚ä¸å®‰ã§ã™ã€‚",
      neutral: "ç‰¹ã«ä½•ã‚‚æ„Ÿã˜ã¾ã›ã‚“ã€‚æ™®é€šã§ã™ã€‚ãµã¤ã†ã§ã™ã€‚ç‰¹ã«å¤‰ã‚ã‚Šã¾ã›ã‚“ã€‚"
    };
    
    // å„æ„Ÿæƒ…ã‚«ãƒ†ã‚´ãƒªã¨ã®é¡ä¼¼åº¦ã‚’è¨ˆç®—
    const emotionScores = {};
    for (const [emotion, examples] of Object.entries(emotionExamples)) {
      emotionScores[emotion] = await global.embeddingService.getTextSimilarity(
        userMessage, 
        examples
      );
    }
    
    // æœ€ã‚‚é«˜ã„ã‚¹ã‚³ã‚¢ã®æ„Ÿæƒ…ã‚’é¸æŠ
    const dominantEmotion = Object.entries(emotionScores)
      .sort((a, b) => b[1] - a[1])[0];
    
    context.userEmotion = dominantEmotion[0];
    context.emotionIntensity = Math.round(dominantEmotion[1] * 10) / 10; // 0ã€œ1ã®ç¯„å›²ã«æ­£è¦åŒ–
    
    // 2. èˆˆå‘³é–¢å¿ƒã®åˆ†æ
    // èˆˆå‘³ã‚’ç¤ºã™ä¾‹æ–‡
    const interestExample = "ç§ã®è¶£å‘³ã¯â—‹â—‹ã§ã™ã€‚â—‹â—‹ã«èˆˆå‘³ãŒã‚ã‚Šã¾ã™ã€‚â—‹â—‹ãŒå¥½ãã§ã™ã€‚â—‹â—‹ãŒæ¥½ã—ã„ã§ã™ã€‚";
    
    // å„ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§èˆˆå‘³é–¢å¿ƒã®åˆ†æ
    for (const msg of allUserMessages) {
      // æ–‡å˜ä½ã§ã®åˆ†æ
      const sentences = msg.split(/ã€‚|ï¼|\.|!/).filter(s => s.length > 5);
      
      for (const sentence of sentences) {
        const interestSimilarity = await global.embeddingService.getTextSimilarity(
          sentence,
          interestExample
        );
        
        // èˆˆå‘³é–¢å¿ƒã‚’è¡¨ã™æ–‡ã§ã‚ã‚Œã°ï¼ˆé–¾å€¤0.7ä»¥ä¸Šï¼‰è¿½åŠ 
        if (interestSimilarity > 0.7) {
          context.userInterests.push(sentence);
        }
      }
    }
    
    // é‡è¤‡ã‚’å‰Šé™¤
    context.userInterests = [...new Set(context.userInterests)];
    
    // userInterestsãŒç©ºã®å ´åˆã¯nullã«è¨­å®š
    if (context.userInterests.length === 0) {
      context.userInterests = null;
    }
    
    // 3. ãƒˆãƒ”ãƒƒã‚¯æŠ½å‡º - æœ€æ–°ã®ä¼šè©±ã‹ã‚‰ä¸»è¦ãªãƒˆãƒ”ãƒƒã‚¯ã‚’æŠ½å‡º
    // æ–‡å…¨ä½“ã‚’çµåˆ
    const allText = allUserMessages.join('. ');
    
    // çŸ­ã„æ–‡ç« ã«åˆ†å‰²
    const segments = allText.split(/ã€‚|ï¼|\.|!/).filter(s => s.length > 5);
    
    // ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’ãƒ¦ãƒ‹ãƒ¼ã‚¯ã«ã—ã¦æœ€æ–°ã®3ã¤ã‚’ä¿æŒ
    context.recentTopics = [...new Set(segments)].slice(-3);
    
    return context;
  } catch (error) {
    console.error('Error in semantic conversation context extraction:', error);
    // ã‚¨ãƒ©ãƒ¼æ™‚ã¯å¾“æ¥ã®ãƒ¡ã‚½ãƒƒãƒ‰ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
    return extractConversationContextLegacy(history, userMessage);
  }
}

/**
 * å¾“æ¥ã®å®Ÿè£…ã«ã‚ˆã‚‹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡ºï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ï¼‰
 */
function extractConversationContextLegacy(history, userMessage) {
  try {
    // Extract recent topics from last 5 messages
    const recentMessages = history.slice(-5);
    
    // Extract user interests
    const userInterests = [];
    const interestKeywords = [
      'è¶£å‘³', 'å¥½ã', 'èˆˆå‘³', 'ãƒ›ãƒ“ãƒ¼', 'æ¥½ã—ã„', 'é–¢å¿ƒ', 
      'ã™ã', 'ãã‚‡ã†ã¿', 'ãŸã®ã—ã„', 'ã‹ã‚“ã—ã‚“'
    ];
    
    recentMessages.forEach(msg => {
      if (msg.role === 'user') {
        for (const keyword of interestKeywords) {
          if (msg.content.includes(keyword)) {
            // Extract the sentence containing the keyword
            const sentences = msg.content.split(/ã€‚|ï¼|\.|!/).filter(s => s.includes(keyword));
            userInterests.push(...sentences);
          }
        }
      }
    });
    
    // Check for emotion indicators
    const emotions = {
      positive: 0,
      negative: 0,
      neutral: 1 // Default to slightly neutral
    };
    
    const positiveWords = [
      'å¬‰ã—ã„', 'æ¥½ã—ã„', 'è‰¯ã„', 'å¥½ã', 'ç´ æ™´ã‚‰ã—ã„', 
      'ã†ã‚Œã—ã„', 'ãŸã®ã—ã„', 'ã‚ˆã„', 'ã™ã', 'ã™ã°ã‚‰ã—ã„'
    ];
    
    const negativeWords = [
      'æ‚²ã—ã„', 'è¾›ã„', 'è‹¦ã—ã„', 'å«Œã„', 'å¿ƒé…', 
      'ã‹ãªã—ã„', 'ã¤ã‚‰ã„', 'ãã‚‹ã—ã„', 'ãã‚‰ã„', 'ã—ã‚“ã±ã„'
    ];
    
    // Check current message for emotion words
    for (const word of positiveWords) {
      if (userMessage.includes(word)) emotions.positive++;
    }
    
    for (const word of negativeWords) {
      if (userMessage.includes(word)) emotions.negative++;
    }
    
    // Return the compiled context
    return {
      userInterests: userInterests.length > 0 ? userInterests : null,
      userEmotion: emotions.positive > emotions.negative ? 'positive' : 
                   emotions.negative > emotions.positive ? 'negative' : 'neutral',
      emotionIntensity: Math.max(emotions.positive, emotions.negative),
      messageCount: history.length,
      recentTopics: recentMessages
        .map(msg => msg.content)
        .join(' ')
        .split(/ã€‚|ï¼|\.|!/)
        .filter(s => s.length > 5)
        .slice(-3)
    };
  } catch (error) {
    console.error('Error extracting conversation context:', error);
    // Return a minimal context object in case of error
    return {
      userEmotion: 'neutral',
      emotionIntensity: 0,
      messageCount: history.length
    };
  }
}

async function processUserMessage(userId, userMessage, history, initialMode = null) {
  try {
    // Start timer for overall processing
    const overallStartTime = Date.now();
    console.log(`\n==== PROCESSING USER MESSAGE (${new Date().toISOString()}) ====`);
    console.log(`User ID: ${userId}`);
    console.log(`Message: ${userMessage.substring(0, 50)}${userMessage.length > 50 ? '...' : ''}`);
    
    // Get user preferences
    // ... existing code ...
  } catch (error) {
    console.error('Error processing user message:', error);
    return {
      type: 'text',
      text: 'ç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚'
    };
  }
}

/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ã®æ¤œè¨¼ã¨ç„¡å®³åŒ–
 * @param {string} input - ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰ã®å…¥åŠ›ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
 * @returns {string} - æ¤œè¨¼æ¸ˆã¿ã®å…¥åŠ›ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
 */
function sanitizeUserInput(input) {
  if (!input) return '';
  
  // æ–‡å­—åˆ—ã§ãªã„å ´åˆã¯æ–‡å­—åˆ—ã«å¤‰æ›
  if (typeof input !== 'string') {
    input = String(input);
  }
  
  // æœ€å¤§é•·ã®åˆ¶é™
  const MAX_INPUT_LENGTH = 2000;
  if (input.length > MAX_INPUT_LENGTH) {
    console.warn(`ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ãŒé•·ã™ãã¾ã™ (${input.length} > ${MAX_INPUT_LENGTH}). åˆ‡ã‚Šè©°ã‚ã¾ã™ã€‚`);
    input = input.substring(0, MAX_INPUT_LENGTH);
  }
  
  // XSSå¯¾ç­– - xssãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨
  input = xss(input);
  
  // SQL Injectionå¯¾ç­– - SQLé–¢é€£ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’æ¤œå‡ºã—ã¦è­¦å‘Š
  const SQL_PATTERN = /\b(SELECT|INSERT|UPDATE|DELETE|DROP|ALTER|UNION|JOIN|WHERE|OR)\b/gi;
  if (SQL_PATTERN.test(input)) {
    console.warn('SQL Injectionã®å¯èƒ½æ€§ãŒã‚ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ã‚’æ¤œå‡ºã—ã¾ã—ãŸ');
    // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ç½®æ›
    input = input.replace(SQL_PATTERN, '***');
  }
  
  return input;
}

/**
 * Line UserIDã®æ¤œè¨¼
 * @param {string} userId - Lineã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ID
 * @returns {string|null} - æ¤œè¨¼æ¸ˆã¿ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã¾ãŸã¯null
 */
function validateUserId(userId) {
  if (!userId || typeof userId !== 'string') {
    console.error('ä¸æ­£ãªãƒ¦ãƒ¼ã‚¶ãƒ¼IDå½¢å¼:', userId);
    return null;
  }
  
  // Line UserIDã®å½¢å¼ãƒã‚§ãƒƒã‚¯ (UUIDv4å½¢å¼)
  const LINE_USERID_PATTERN = /^U[a-f0-9]{32}$/i;
  if (!LINE_USERID_PATTERN.test(userId)) {
    console.error('Line UserIDã®å½¢å¼ãŒä¸æ­£ã§ã™:', userId);
    return null;
  }
  
  return userId;
}

// Add cleanup for the tracking map every hour
// Setup a cleanup interval for recentImageGenerationUsers
setInterval(() => {
  const now = Date.now();
  recentImageGenerationUsers.forEach((timestamp, userId) => {
    // Remove entries older than 1 hour
    if (now - timestamp > 3600000) {
      recentImageGenerationUsers.delete(userId);
    }
  });
}, 3600000); // Clean up every hour

// Export functions for use in other modules
module.exports = {
  fetchUserHistory
};

/**
 * ä¼šè©±å±¥æ­´ã‹ã‚‰ç‰¹æ€§åˆ†æã‚’è¡Œã„ã€ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
 * @param {Array} history - ä¼šè©±å±¥æ­´ã®é…åˆ—
 * @returns {Promise<string>} - åˆ†æçµæœã®ãƒ†ã‚­ã‚¹ãƒˆ
 */
async function generateHistoryResponse(history) {
  try {
    console.log(`\n======= ç‰¹æ€§åˆ†æè©³ç´°ãƒ­ã‚° =======`);
    
    // ä¼šè©±å±¥æ­´ãŒç©ºã®å ´åˆ
    if (!history || history.length === 0) {
      console.log(`â†’ ä¼šè©±å±¥æ­´ãªã—: ç©ºã®historyã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ`);
      return "ä¼šè©±å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã‚‚ã†å°‘ã—ä¼šè©±ã‚’ç¶šã‘ã‚‹ã¨ã€ã‚ãªãŸã®ç‰¹æ€§ã«ã¤ã„ã¦åˆ†æã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚";
    }

    console.log(`â†’ åˆ†æé–‹å§‹: ${history.length}ä»¶ã®ä¼šè©±ãƒ¬ã‚³ãƒ¼ãƒ‰`);
    
    // ä¼šè©±å±¥æ­´ã‹ã‚‰ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã¿ã‚’æŠ½å‡º
    const userMessages = history.filter(msg => msg.role === 'user').map(msg => msg.content);
    console.log(`â†’ ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æŠ½å‡º: ${userMessages.length}ä»¶`);
    
    // åˆ†æã«ååˆ†ãªãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªï¼ˆæœ€ä½1ä»¶ã‚ã‚Œã°åˆ†æã‚’è©¦ã¿ã‚‹ï¼‰
    if (userMessages.length > 0) {
      console.log(`â†’ OpenAI APIå‘¼ã³å‡ºã—æº–å‚™å®Œäº†`);
      console.log(`â†’ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆä»˜ä¸: "ãŸã¨ãˆãƒ‡ãƒ¼ã‚¿ãŒå°‘ãªãã¦ã‚‚ã€ã€Œéå»ã®è¨˜éŒ²ãŒãªã„ã€ãªã©ã¨ã¯è¨€ã‚ãšã€åˆ©ç”¨å¯èƒ½ãªãƒ‡ãƒ¼ã‚¿ã‹ã‚‰æœ€å¤§é™ã®åˆ†æã‚’è¡Œã£ã¦ãã ã•ã„"`);
      
      // OpenAI APIã‚’ä½¿ç”¨ã—ã¦ç‰¹æ€§åˆ†æã‚’å®Ÿè¡Œ
      const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
      
      const response = await openai.chat.completions.create({
        model: "gpt-4o",
        messages: [
          {
            role: "system",
            content: `ã‚ãªãŸã¯ã€ŒAdamã€ã¨ã„ã†ç™ºé”éšœå®³å°‚é–€ã®ã‚«ã‚¦ãƒ³ã‚»ãƒ©ãƒ¼ã§ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®éå»ãƒ­ã‚°ã‚’åˆ†æã—ã€ä»¥ä¸‹ã®è¦³ç‚¹ã‹ã‚‰æ·±ã„æ´å¯Ÿã‚’æä¾›ã—ã¦ãã ã•ã„ã€‚

[åˆ†æã®è¦³ç‚¹]
1. ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³
   - è¨€è‘‰é£ã„ã®ç‰¹å¾´
   - è¡¨ç¾ã®ä¸€è²«æ€§
   - æ„Ÿæƒ…è¡¨ç¾ã®æ–¹æ³•

2. æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹
   - è«–ç†çš„æ€è€ƒã®ç‰¹å¾´
   - å•é¡Œè§£æ±ºã‚¢ãƒ—ãƒ­ãƒ¼ãƒ
   - èˆˆå‘³ãƒ»é–¢å¿ƒã®å¯¾è±¡

3. ç¤¾ä¼šçš„ç›¸äº’ä½œç”¨
   - å¯¾äººé–¢ä¿‚ã§ã®å‚¾å‘
   - ã‚¹ãƒˆãƒ¬ã‚¹å¯¾å‡¦æ–¹æ³•
   - ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ä¸Šã®å¼·ã¿/èª²é¡Œ

4. æ„Ÿæƒ…ã¨è‡ªå·±èªè­˜
   - æ„Ÿæƒ…è¡¨ç¾ã®ç‰¹å¾´
   - è‡ªå·±ç†è§£ã®ç¨‹åº¦
   - ãƒ¢ãƒãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ã®æºæ³‰

[å‡ºåŠ›å½¢å¼]
- æ—¥æœ¬èªã§ç°¡æ½”ã«ï¼ˆ200æ–‡å­—ä»¥å†…ï¼‰
- è‚¯å®šçš„ãªå´é¢ã‚’å«ã‚ã‚‹
- æ”¹å–„ææ¡ˆã‚ã‚Œã°æ·»ãˆã‚‹
- æ–­å®šçš„ãªè¨ºæ–­ã¯é¿ã‘ã‚‹ï¼ˆå°‚é–€åŒ»ã«ç›¸è«‡ã‚’æ¨å¥¨ã™ã‚‹ï¼‰
- ã€Œãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³ã—ã¦ã„ã‚‹ã€ã€Œåˆ†æã§ããªã„ã€ã€Œè¨˜éŒ²ãŒå°‘ãªã„ã€ãªã©ã®å¦å®šçš„ãªè¡¨ç¾ã¯é¿ã‘ã€é™ã‚‰ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ã§ã‚‚ä½•ã‚‰ã‹ã®æ´å¯Ÿã‚’æä¾›ã™ã‚‹
- å°‚é–€å®¶ã¸ã®ç›¸è«‡ã‚’æ¨å¥¨ã™ã‚‹

é‡è¦: ãŸã¨ãˆãƒ‡ãƒ¼ã‚¿ãŒå°‘ãªãã¦ã‚‚ã€ã€Œéå»ã®è¨˜éŒ²ãŒãªã„ã€ã€Œãƒ‡ãƒ¼ã‚¿ãŒå°‘ãªã„ã€ã€Œã“ã‚Œã¾ã§ã®è¨˜éŒ²ãŒå°‘ãªã„ã€ãªã©ã®è¡¨ç¾ã¯çµ¶å¯¾ã«ä½¿ã‚ãšã€åˆ©ç”¨å¯èƒ½ãªãƒ‡ãƒ¼ã‚¿ã‹ã‚‰æœ€å¤§é™ã®å…·ä½“çš„ãªåˆ†æã‚’è¡Œã£ã¦ãã ã•ã„ã€‚ãƒ‡ãƒ¼ã‚¿é‡ã«ã¤ã„ã¦ã®è¨€åŠã¯ä¸€åˆ‡é¿ã‘ã€ç›´æ¥åˆ†æå†…å®¹ã‚’ä¼ãˆã¦ãã ã•ã„ã€‚`
          },
          {
            role: "user",
            content: `ä»¥ä¸‹ã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®éå»ã®ä¼šè©±å±¥æ­´ã§ã™ã€‚ã“ã®æƒ…å ±ã‚’åŸºã«ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ç‰¹æ€§ã«ã¤ã„ã¦åˆ†æã—ã¦ãã ã•ã„ã€‚
            
ä¼šè©±å±¥æ­´:
${userMessages.join('\n\n')}`
          }
        ],
        max_tokens: 500
      });
      
      console.log(`â†’ OpenAI APIå¿œç­”å—ä¿¡: ${response.choices[0].message.content.substring(0, 50)}...`);
      console.log(`â†’ ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒã€Œéå»ã®è¨˜éŒ²ãŒãªã„ã€ã‚’å«ã‚€ã‹: ${response.choices[0].message.content.includes('éå»ã®è¨˜éŒ²ãŒãªã„') || response.choices[0].message.content.includes('ä¼šè©±å±¥æ­´ãŒãªã„')}`);
      console.log(`======= ç‰¹æ€§åˆ†æè©³ç´°ãƒ­ã‚°çµ‚äº† =======\n`);
      return response.choices[0].message.content;
    } else {
      console.log(`â†’ åˆ†æã«åˆ©ç”¨å¯èƒ½ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãªã—`);
      console.log(`======= ç‰¹æ€§åˆ†æè©³ç´°ãƒ­ã‚°çµ‚äº† =======\n`);
      // ä¼šè©±å±¥æ­´ãŒä¸è¶³ã—ã¦ã„ã‚‹å ´åˆã§ã‚‚ã€å¦å®šçš„ãªè¡¨ç¾ã¯é¿ã‘ã‚‹
      return "ä¼šè©±å±¥æ­´ã‚’åˆ†æã—ã¾ã—ãŸã€‚ã‚ˆã‚Šè©³ç´°ãªç‰¹æ€§åˆ†æã®ãŸã‚ã«ã¯ã€ã‚‚ã†å°‘ã—ä¼šè©±ã‚’ç¶šã‘ã‚‹ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚ç¾æ™‚ç‚¹ã§ã¯ã€ã‚ãªãŸã®èˆˆå‘³ã‚„é–¢å¿ƒã«åˆã‚ã›ãŸã‚µãƒãƒ¼ãƒˆã‚’æä¾›ã§ãã‚‹ã‚ˆã†åŠªã‚ã¦ã„ã¾ã™ã€‚ä½•ã‹å…·ä½“çš„ãªè³ªå•ã‚„è©±é¡ŒãŒã‚ã‚Œã°ã€ãŠæ°—è»½ã«ãŠèã‹ã›ãã ã•ã„ã€‚";
    }
  } catch (error) {
    console.error('Error in generateHistoryResponse:', error);
    console.error(`â†’ ã‚¨ãƒ©ãƒ¼ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹: ${error.stack}`);
    console.log(`======= ç‰¹æ€§åˆ†æè©³ç´°ãƒ­ã‚°çµ‚äº† (ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ) =======\n`);
    // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã§ã‚‚ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ãƒ¬ãƒ³ãƒ‰ãƒªãƒ¼ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿”ã™
    return "ç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ã€‚ç‰¹æ€§åˆ†æã®å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ã„ãŸã ãã‹ã€åˆ¥ã®è³ªå•ã‚’ã—ã¦ã„ãŸã ã‘ã¾ã™ã‹ï¼Ÿ";
  }
}

/**
 * æ··ä¹±ã‚„ç†è§£å›°é›£ã‚’ç¤ºã™è¡¨ç¾ã‚’å«ã‚€ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹
 * @param {string} text - ãƒã‚§ãƒƒã‚¯ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
 * @return {boolean} - æ··ä¹±è¡¨ç¾ã‚’å«ã‚€å ´åˆã¯true
 */
function containsConfusionTerms(text) {
  if (!text || typeof text !== 'string') return false;
  
  // ä¸€èˆ¬çš„ãªæ··ä¹±è¡¨ç¾
  const confusionTerms = [
    'ã‚ã‹ã‚‰ãªã„', 'åˆ†ã‹ã‚‰ãªã„', 'ç†è§£ã§ããªã„', 'æ„å‘³ãŒã‚ã‹ã‚‰ãªã„', 'æ„å‘³ãŒåˆ†ã‹ã‚‰ãªã„',
    'ã©ã†ã„ã†æ„å‘³', 'ã©ã†ã„ã†ã“ã¨', 'ã‚ˆãã‚ã‹ã‚‰ãªã„', 'ã‚ˆãåˆ†ã‹ã‚‰ãªã„',
    'ä½•ãŒè¨€ã„ãŸã„', 'ãªã«ãŒè¨€ã„ãŸã„', 'ä½•ã‚’è¨€ã£ã¦ã‚‹', 'ãªã«ã‚’è¨€ã£ã¦ã‚‹',
    'ã‚‚ã†å°‘ã—', 'ã‚‚ã£ã¨', 'ç°¡å˜ã«', 'ã‹ã¿ç •ã„ã¦', 'ã‚·ãƒ³ãƒ—ãƒ«ã«', 'ä¾‹ã‚’æŒ™ã’ã¦',
    'é•ã†æ–¹æ³•ã§', 'åˆ¥ã®è¨€ã„æ–¹', 'è¨€ã„æ›ãˆã‚‹ã¨', 'è¨€ã„æ›ãˆã‚Œã°', 'è©³ã—ã',
    'æ··ä¹±', 'è¤‡é›‘', 'é›£è§£', 'ã‚€ãšã‹ã—ã„'
  ];
  
  return confusionTerms.some(term => text.includes(term));
}

/**
 * ç›´æ¥çš„ãªç”»åƒåˆ†æãƒªã‚¯ã‚¨ã‚¹ãƒˆã‹ã©ã†ã‹ã‚’åˆ¤æ–­ã™ã‚‹
 * @param {string} text - ãƒã‚§ãƒƒã‚¯ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
 * @return {boolean} - ç›´æ¥çš„ãªç”»åƒåˆ†æãƒªã‚¯ã‚¨ã‚¹ãƒˆã®å ´åˆã¯true
 */
function isDirectImageAnalysisRequest(text) {
  if (!text || typeof text !== 'string') return false;
  
  // ç”»åƒåˆ†æã«ç‰¹åŒ–ã—ãŸãƒ•ãƒ¬ãƒ¼ã‚º
  const directAnalysisRequests = [
    'ã“ã®ç”»åƒã«ã¤ã„ã¦', 'ã“ã®å†™çœŸã«ã¤ã„ã¦', 'ã“ã®ç”»åƒã‚’åˆ†æ', 'ã“ã®å†™çœŸã‚’åˆ†æ',
    'ã“ã®ç”»åƒã‚’è§£æ', 'ã“ã®å†™çœŸã‚’è§£æ', 'ã“ã®ç”»åƒã‚’èª¬æ˜', 'ã“ã®å†™çœŸã‚’èª¬æ˜',
    'ã“ã®ç”»åƒã®å†…å®¹', 'ã“ã®å†™çœŸã®å†…å®¹', 'ã“ã®ç”»åƒã«å†™ã£ã¦ã„ã‚‹ã‚‚ã®', 'ã“ã®å†™çœŸã«å†™ã£ã¦ã„ã‚‹ã‚‚ã®'
  ];
  
  // ç›´æ¥çš„ãªç”»åƒåˆ†æãƒªã‚¯ã‚¨ã‚¹ãƒˆã®å ´åˆã¯trueã‚’è¿”ã™
  return directAnalysisRequests.some(phrase => text.includes(phrase));
}

// å®šæ•°å®£è¨€ã®éƒ¨åˆ†ã®å¾Œã«è¿½åŠ 
const PENDING_IMAGE_TIMEOUT = 5 * 60 * 1000; // 5åˆ†ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ

// server.jså†…ã®èµ·å‹•å‡¦ç†éƒ¨åˆ†ï¼ˆé€šå¸¸ã¯expressã‚¢ãƒ—ãƒªã®åˆæœŸåŒ–å¾Œï¼‰ã«è¿½åŠ 
// ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³èµ·å‹•æ™‚ã«ã‚·ã‚¹ãƒ†ãƒ ã‚¹ãƒ†ãƒ¼ãƒˆã‚’å¾©å…ƒã™ã‚‹é–¢æ•°
async function restoreSystemState() {
  try {
    console.log('Restoring system state from persistent storage...');
    
    // ä¿ç•™ä¸­ã®ç”»åƒç”Ÿæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆã®å¾©å…ƒ
    await restorePendingImageRequests();
    
    console.log('System state restoration completed');
  } catch (error) {
    console.error('Error restoring system state:', error);
  }
}

// ä¼šè©±å±¥æ­´ã‹ã‚‰ä¿ç•™ä¸­ã®ç”»åƒç”Ÿæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å¾©å…ƒã™ã‚‹é–¢æ•°
async function restorePendingImageRequests() {
  try {
    console.log('Attempting to restore pending image generation requests...');
    
    if (!process.env.AIRTABLE_API_KEY || !process.env.AIRTABLE_BASE_ID) {
      console.log('Airtable credentials not found. Cannot restore pending image requests.');
      return;
    }
    
    // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã®airtableBaseã‚’ä½¿ç”¨
    if (!airtableBase) {
      console.error('Airtable connection not initialized. Cannot restore pending image requests.');
      return;
    }
    
    // æœ€è¿‘ã®ç”»åƒç”Ÿæˆææ¡ˆã‚’æ¤œç´¢ï¼ˆéå»30åˆ†ä»¥å†…ï¼‰
    const cutoffTime = new Date(Date.now() - 30 * 60 * 1000); // 30åˆ†å‰
    const cutoffTimeStr = cutoffTime.toISOString();
    
    const pendingProposals = await airtableBase('ConversationHistory')
      .select({
        filterByFormula: `AND(SEARCH("[ç”»åƒç”Ÿæˆææ¡ˆ]", {Content}) > 0, {Timestamp} > "${cutoffTimeStr}")`,
        sort: [{ field: 'Timestamp', direction: 'desc' }]
      })
      .firstPage();
    
    console.log(`Found ${pendingProposals.length} recent image generation proposals`);
    
    // å„ææ¡ˆã«ã¤ã„ã¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å¿œç­”ã‚’ãƒã‚§ãƒƒã‚¯
    for (const proposal of pendingProposals) {
      const userId = proposal.get('UserID');
      const proposalTime = new Date(proposal.get('Timestamp')).getTime();
      const now = Date.now();
      
      // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒã‚§ãƒƒã‚¯
      if (now - proposalTime > PENDING_IMAGE_TIMEOUT) {
        console.log(`Skipping expired proposal for user ${userId} (${Math.round((now - proposalTime)/1000)}s old)`);
        continue;
      }
      
      // ææ¡ˆå¾Œã®ãƒ¦ãƒ¼ã‚¶ãƒ¼å¿œç­”ã‚’ç¢ºèª
      const userResponses = await airtableBase('ConversationHistory')
        .select({
          filterByFormula: `AND({UserID} = "${userId}", {Role} = "user", {Timestamp} > "${proposal.get('Timestamp')}")`,
          sort: [{ field: 'Timestamp', direction: 'asc' }]
        })
        .firstPage();
      
      console.log(`[DEBUG-RESTORE] User ${userId}: proposal time=${new Date(proposalTime).toISOString()}, found ${userResponses.length} responses after proposal`);
      
      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå¿œç­”ã—ã¦ã„ãªã„å ´åˆã€ææ¡ˆã‚’ä¿ç•™ä¸­ã¨ã—ã¦å¾©å…ƒ
      if (userResponses.length === 0) {
        console.log(`[DEBUG-RESTORE] Restoring pending image proposal for user ${userId} - no responses found after proposal`);
        
        // æœ€å¾Œã®ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å–å¾—ï¼ˆææ¡ˆã®ç›´å‰ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼‰
        const lastMessages = await airtableBase('ConversationHistory')
          .select({
            filterByFormula: `AND({UserID} = "${userId}", {Role} = "assistant", {Timestamp} < "${proposal.get('Timestamp')}")`,
            sort: [{ field: 'Timestamp', direction: 'desc' }],
            maxRecords: 1
          })
          .firstPage();
        
        if (lastMessages.length > 0) {
          const content = lastMessages[0].get('Content');
          pendingImageExplanations.set(userId, {
            content: content,
            timestamp: proposalTime
          });
          console.log(`[DEBUG-RESTORE] Restored pending image explanation for user ${userId} with content: "${content.substring(0, 30)}..." at timestamp ${new Date(proposalTime).toISOString()}`);
        } else {
          console.log(`[DEBUG-RESTORE] Could not find assistant message before proposal for user ${userId}`);
        }
      } else {
        console.log(`[DEBUG-RESTORE] User ${userId} already responded after proposal, not restoring`);
        if (userResponses.length > 0) {
          console.log(`[DEBUG-RESTORE] First response: "${userResponses[0].get('Content')}" at ${userResponses[0].get('Timestamp')}`);
        }
      }
    }
    
    // å¾©å…ƒã•ã‚ŒãŸå†…å®¹ã®è©³ç´°ãªãƒ‡ãƒãƒƒã‚°æƒ…å ±
    if (pendingImageExplanations.size > 0) {
      console.log('=== Restored pending image requests details ===');
      for (const [uid, data] of pendingImageExplanations.entries()) {
        console.log(`User ${uid}: timestamp=${new Date(data.timestamp).toISOString()}, age=${Math.round((Date.now() - data.timestamp)/1000)}s, contentLen=${data.content.length}`);
        console.log(`Content preview: "${data.content.substring(0, 30)}..."`);
      }
      console.log('============================================');
    } else {
      console.log('No valid pending image requests were found to restore');
    }
    
    console.log(`Successfully restored ${pendingImageExplanations.size} pending image requests`);
  } catch (error) {
    console.error('Error restoring pending image requests:', error);
  }
}

// ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³èµ·å‹•æ™‚ã«çŠ¶æ…‹ã‚’å¾©å…ƒ
restoreSystemState();

/**
 * Use GPT-4o-mini to determine if user is asking for advice or in need of service recommendations
 */
async function detectAdviceRequestWithLLM(userMessage, history) {
  try {
    console.log('Using LLM to analyze if user needs service recommendations');
    
    const prompt = `
ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ¬¡ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‹ã‚‰ã€ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚„ã‚µãƒ¼ãƒ“ã‚¹ã®æ¨è–¦ã‚’æ±‚ã‚ã¦ã„ã‚‹ã‹ã€ã¾ãŸã¯å›°ã£ãŸçŠ¶æ³ã«ã‚ã‚‹ã‹ã‚’åˆ¤æ–­ã—ã¦ãã ã•ã„:

"${userMessage}"

åˆ¤æ–­åŸºæº–:
1. ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ˜ç¤ºçš„ã«ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚„ã‚µãƒ¼ãƒ“ã‚¹ã®æ¨è–¦ã‚’æ±‚ã‚ã¦ã„ã‚‹
2. ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå›°ã£ãŸçŠ¶æ³ã‚„å•é¡Œã‚’æŠ±ãˆã¦ãŠã‚Šã€ã‚µãƒ¼ãƒ“ã‚¹æ¨è–¦ãŒå½¹ç«‹ã¤å¯èƒ½æ€§ãŒã‚ã‚‹
3. å˜ãªã‚‹é›‘è«‡ã‚„ãŠç¤¼ã®å ´åˆã¯æ¨è–¦ä¸è¦
4. ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ¨è–¦ã‚’æ‹’å¦ã—ã¦ã„ã‚‹å ´åˆã¯æ¨è–¦ä¸è¦

å¿œç­”ã¯ã€Œyesã€ã¾ãŸã¯ã€Œnoã€ã®ã¿ã§ç­”ãˆã¦ãã ã•ã„ã€‚
`;

    const openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
    
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: "ã‚ãªãŸã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ„å›³ã‚’æ­£ç¢ºã«åˆ¤æ–­ã™ã‚‹AIã§ã™ã€‚yes/noã®ã¿ã§å›ç­”ã—ã¦ãã ã•ã„ã€‚" },
        { role: "user", content: prompt }
      ],
      temperature: 0.1,
      max_tokens: 10
    });
    
    const result = response.choices[0].message.content.trim().toLowerCase();
    
    // è©³ç´°ãªãƒ­ã‚°ã‚’è¿½åŠ 
    if (result === 'yes') {
      console.log(`âœ… Advice request detected by LLM: "${userMessage.substring(0, 50)}${userMessage.length > 50 ? '...' : ''}"`);
    } else {
      console.log(`âŒ No advice request detected by LLM: "${userMessage.substring(0, 50)}${userMessage.length > 50 ? '...' : ''}"`);
    }
    
    return result === 'yes';
  } catch (error) {
    console.error('Error in LLM advice request detection:', error);
    // Fall back to simpler heuristic in case of error
    console.log(`âš ï¸ Error in advice request detection, defaulting to false`);
    return false;
  }
}

/**
 * [æ–°æ©Ÿèƒ½] æ‹¡å¼µEmbeddingæ©Ÿèƒ½ã¸ã®æ©‹æ¸¡ã—
 * æ—¢å­˜ã®æ©Ÿèƒ½ã‚’å¤‰æ›´ã›ãšã€æ©Ÿèƒ½ã‚’è¿½åŠ ã™ã‚‹ãŸã‚ã®é–¢æ•°
 * global.detectAdviceRequestWithLLMã¸ã®å‚ç…§ã‚’è¨­å®š
 */
// ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«é–¢æ•°ã‚’å…¬é–‹ï¼ˆä»–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰ã®ã‚¢ã‚¯ã‚»ã‚¹ç”¨ï¼‰
global.detectAdviceRequestWithLLM = detectAdviceRequestWithLLM;
global.isConfusionRequest = isConfusionRequest;
global.isDeepExplorationRequest = isDeepExplorationRequest;

// æ‹¡å¼µæ©Ÿèƒ½ã®ã‚µãƒãƒ¼ãƒˆç”¨ãƒ˜ãƒ«ãƒ‘ãƒ¼ï¼ˆåˆæœŸåŒ–ãŒæ¸ˆã‚“ã§ã„ãªã„å ´åˆã«å®‰å…¨ã«å®Ÿè¡Œï¼‰
const initializeEmbeddingBridge = async () => {
  try {
    // ã‚µãƒ¼ãƒ“ã‚¹ãƒãƒƒãƒãƒ³ã‚°æ©Ÿèƒ½ã®åˆæœŸåŒ–ã¨çµ„ã¿è¾¼ã¿
    if (typeof enhancedServiceMatching === 'undefined' && fs.existsSync('./enhancedServiceMatching.js')) {
      global.enhancedServiceMatching = require('./enhancedServiceMatching');
      await global.enhancedServiceMatching.initialize();
      console.log('Enhanced service matching bridge initialized successfully');
    }
    
    // ç”»åƒåˆ¤æ–­æ©Ÿèƒ½ã®åˆæœŸåŒ–ã¨çµ„ã¿è¾¼ã¿
    if (typeof enhancedImageDecision === 'undefined' && fs.existsSync('./enhancedImageDecision.js')) {
      global.enhancedImageDecision = require('./enhancedImageDecision');
      await global.enhancedImageDecision.initialize();
      console.log('Enhanced image decision bridge initialized successfully');
    }
  } catch (error) {
    console.error('Error initializing embedding bridges:', error);
  }
};

// éåŒæœŸã§æ‹¡å¼µæ©Ÿèƒ½ã‚’åˆæœŸåŒ–ï¼ˆã‚µãƒ¼ãƒãƒ¼èµ·å‹•ã‚’é…å»¶ã•ã›ãªã„ï¼‰
setTimeout(initializeEmbeddingBridge, 2000);

/**
 * Check if it's an appropriate time in the conversation to show service recommendations
 */
async function shouldShowServicesToday(userId, history, userMessage) {
  // æ‹¡å¼µæ©Ÿèƒ½ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆã¯ãã¡ã‚‰ã‚’ä½¿ç”¨
  if (global.enhancedServiceMatching) {
    try {
      const enhancedDecision = await global.enhancedServiceMatching.shouldShowServiceRecommendation(
        userMessage, 
        history, 
        userId
      );
      console.log(`[DEBUG] Enhanced service recommendation decision: ${enhancedDecision}`);
      return enhancedDecision;
    } catch (error) {
      console.error('[ERROR] Enhanced service recommendation failed, falling back to standard method:', error.message);
      // å¾“æ¥ã®æ–¹æ³•ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
    }
  }
  
  // If user explicitly asks for advice/services, always show
  const isAdviceRequest = await detectAdviceRequestWithLLM(userMessage, history);
  if (isAdviceRequest) {
    console.log('âœ… Advice request detected by LLM in shouldShowServicesToday - always showing services');
    return true;
  }
  
  try {
    // Use a shared function to get/set last service time
    const userPrefs = userPreferences.getUserPreferences(userId);
    const lastServiceTime = userPrefs.lastServiceTime || 0;
    const now = Date.now();
    
    // If user recently received service recommendations (within last 4 hours)
    if (lastServiceTime > 0 && now - lastServiceTime < 4 * 60 * 60 * 1000) {
      // Count total service recommendations today
      const todayStart = new Date();
      todayStart.setHours(0, 0, 0, 0);
      
      let servicesToday = 0;
      if (userPrefs.recentlyShownServices) {
        for (const timestamp in userPrefs.recentlyShownServices) {
          if (parseInt(timestamp) > todayStart.getTime()) {
            servicesToday += userPrefs.recentlyShownServices[timestamp].length;
          }
        }
      }
      
      // Limit to no more than 9 service recommendations per day
      if (servicesToday >= 9) {
        console.log('âš ï¸ Daily service recommendation limit reached (9 per day) - not showing services');
        return false;
      }
      
      // If fewer than 5 service recommendations today, require a longer minimum gap
      if (servicesToday < 5 && now - lastServiceTime < 45 * 60 * 1000) {
        console.log(`âš ï¸ Time between service recommendations too short (< 45 minutes) - not showing services. Last shown: ${Math.round((now - lastServiceTime) / 60000)} minutes ago`);
        return false; // Less than 45 minutes since last recommendation
      }
    }

    return true;
  } catch (err) {
    console.error('Error in shouldShowServicesToday:', err);
    return true; // Default to showing if there's an error
  }
}

/**
 * Safety check for images using OpenAI's moderation capability with GPT-4o-mini
 * @param {string} base64Image - Base64 encoded image
 * @return {Promise<boolean>} - Whether the image passed the safety check
 */
async function checkImageSafety(base64Image) {
  try {
    // Using OpenAI's GPT-4o-mini model to detect potential safety issues
    const openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
    
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "system",
          content: "ã‚ãªãŸã¯ç”»åƒãƒ¢ãƒ‡ãƒ¬ãƒ¼ã‚¿ãƒ¼ã§ã™ã€‚ã“ã®ç”»åƒãŒå®‰å…¨ã‹ã©ã†ã‹ã‚’åˆ¤æ–­ã—ã¦ãã ã•ã„ã€‚ç”»åƒãŒæš´åŠ›çš„ã€æ€§çš„ã€ã¾ãŸã¯ä¸é©åˆ‡ãªå†…å®¹ãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã€ãã‚Œã‚’ç‰¹å®šã—ã¦ãã ã•ã„ã€‚å›ç­”ã¯ã€ŒSAFEã€ã¾ãŸã¯ã€ŒUNSAFEã€ã§å§‹ã‚ã¦ãã ã•ã„ã€‚"
        },
        {
          role: "user",
          content: [
            { 
              type: "image_url", 
              image_url: {
                url: `data:image/jpeg;base64,${base64Image}`
              }
            }
          ]
        }
      ],
      max_tokens: 150,
      temperature: 0
    });
    
    const moderationResult = response.choices[0].message.content;
    console.log(`Image safety check (4o-mini): ${moderationResult}`);
    
    // If the response starts with UNSAFE, the image didn't pass the safety check
    return !moderationResult.startsWith("UNSAFE");
  } catch (error) {
    console.error('Error in image safety check:', error);
    // In case of error, assume the image is safe to not block valid images
    return true;
  }
}

// Near the end of the file where global.isConfusionRequest is defined

// Make isDeepExplorationRequest globally accessible
global.isDeepExplorationRequest = isDeepExplorationRequest;

// Export functions to make them available to other modules
module.exports = {
  // ... existing exports ...
  isConfusionRequest,
  isDeepExplorationRequest,
  // ... existing exports ...
};
